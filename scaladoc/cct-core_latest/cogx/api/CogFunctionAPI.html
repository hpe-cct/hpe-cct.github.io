<!DOCTYPE html >
<html>
        <head>
          <title>CogFunctionAPI - cogx.api.CogFunctionAPI</title>
          <meta name="description" content="CogFunctionAPI - cogx.api.CogFunctionAPI" />
          <meta name="keywords" content="CogFunctionAPI cogx.api.CogFunctionAPI" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../index.html';
            var hash = 'cogx.api.CogFunctionAPI';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img alt="Trait" src="../../lib/trait_big.png" />
        <p id="owner"><a href="../package.html" class="extype" name="cogx">cogx</a>.<a href="package.html" class="extype" name="cogx.api">api</a></p>
        <h1>CogFunctionAPI</h1><h3><span class="morelinks"><div>Related Doc:
            <a href="package.html" class="extype" name="cogx.api">package api</a>
          </div></span></h3><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">CogFunctionAPI</span><span class="result"> extends <span class="extype" name="cogx.compiler.parser.semantics.SemanticError">SemanticError</span> with <a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Function API for Cog.</p><p>Algebraic operators are defined in CogOperatorAPI.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a>, <span class="extype" name="cogx.compiler.parser.semantics.SemanticError">SemanticError</span>, <span class="extype" name="cogx.compiler.CompilerError">CompilerError</span>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block">
            <span class="toggle">Known Subclasses</span>
            <div class="subClasses hiddenContent"><a href="../CogXInterface.html" class="extype" name="cogx.CogXInterface">CogXInterface</a>, <a href="../compiler/parser/syntaxtree/Field$.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></div>
          </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="cogx.api.CogFunctionAPI"><span>CogFunctionAPI</span></li><li class="in" name="cogx.api.ImplicitConversions"><span>ImplicitConversions</span></li><li class="in" name="cogx.compiler.parser.semantics.SemanticError"><span>SemanticError</span></li><li class="in" name="cogx.compiler.CompilerError"><span>CompilerError</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@!=(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@##():Int" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@==(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#abs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="abs(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="abs(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">abs</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@abs(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the absolute value of every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the absolute value of every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       absoluteValue(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#acos" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acos(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="acos(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acos</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@acos(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the arccosine of every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the arccosine of every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       acos(x).</p></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@asInstanceOf[T0]:T0" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#asin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asin(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="asin(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asin</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@asin(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the arcsine of every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the arcsine of every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       asin(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#atan2" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="atan2(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="atan2(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">atan2</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="f2">f2: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@atan2(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute atan2 of two identically shaped scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Compute atan2 of two identically shaped scalar fields.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field that's the atan2 of the two input fields.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#backProjectFrame" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="backProjectFrame(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="backProjectFrame(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">backProjectFrame</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="filter">filter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../package.html">NoSamplingConvolution</a></span></span></span>, <span name="batchSize">batchSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@backProjectFrame(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convolve a vector field with a vector-field filter frame.</p><div class="fullcomment"><div class="comment cmt"><p>Convolve a vector field with a vector-field filter frame.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for convolution; must be square and with
       odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling convolution along borders,
       implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       convolution, also helps to determine the size of output field.</p></dd><dt class="param">batchSize</dt><dd class="cmt"><p>The number of logical (possibly multi-plane) images present in the input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field convolved with <code>filter</code> using the supplied border
       and sampling policies.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#backwardDivergence" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="backwardDivergence(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="backwardDivergence(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">backwardDivergence</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@backwardDivergence(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the backward divergence of a 2D vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the backward divergence of a 2D vector field.</p><p>This is the adjoint operator of forwardGradient.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field representing the backward divergence of an
       input vector field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#backwardGradient" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="backwardGradient(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="backwardGradient(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">backwardGradient</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@backwardGradient(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the backward gradient of a 2D scalar or vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the backward gradient of a 2D scalar or vector field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>For a scalar field input, a vector field representing the
        forward gradient of the input; for a vector input field, an
        order 4 tensor field representing the forward gradient of the
        input.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#blockReduceMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockReduceMax(field:cogx.compiler.parser.syntaxtree.Field,factor:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="blockReduceMax(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockReduceMax</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="factor">factor: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@blockReduceMax(field:cogx.compiler.parser.syntaxtree.Field,factor:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
taking the max() of the first <code>factor</code> input vector elements to form the
first output vector element, and so forth.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
taking the max() of the first <code>factor</code> input vector elements to form the
first output vector element, and so forth.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">factor</dt><dd class="cmt"><p>The factor by which the input field tensor length is reduced.</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field with each element equal to the max() of <code>factor</code>
        components of the corresponding vector in the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#blockReduceMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockReduceMin(field:cogx.compiler.parser.syntaxtree.Field,factor:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="blockReduceMin(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockReduceMin</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="factor">factor: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@blockReduceMin(field:cogx.compiler.parser.syntaxtree.Field,factor:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
taking the min() of the first <code>factor</code> input vector elements to form the
first output vector element, and so forth.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
taking the min() of the first <code>factor</code> input vector elements to form the
first output vector element, and so forth.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">factor</dt><dd class="cmt"><p>The factor by which the input field tensor length is reduced.</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field with each element equal to the min() of <code>factor</code>
        components of the corresponding vector in the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#blockReduceSum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockReduceSum(field:cogx.compiler.parser.syntaxtree.Field,factor:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="blockReduceSum(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockReduceSum</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="factor">factor: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@blockReduceSum(field:cogx.compiler.parser.syntaxtree.Field,factor:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
summing the first <code>factor</code> input vector elements to form the first output
vector element, and so forth.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
summing the first <code>factor</code> input vector elements to form the first output
vector element, and so forth.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">factor</dt><dd class="cmt"><p>The factor by which the input field tensor length is reduced.</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field with each element equal to the sum of <code>factor</code>
        components of the corresponding vector in the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#centralGradient" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="centralGradient(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="centralGradient(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">centralGradient</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@centralGradient(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the central gradient of a scalar of vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the central gradient of a scalar of vector field.</p><p>The central gradient at the point (x, y) is computed using the values at
(x - 1, y), (x, y - 1), (x, y + 1), and (x + 1, y + 1)
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>For a scalar field input, returns a vectorField representing the
       central gradient of the input. For a vector field input, returns
       an order-4 tensor field representing the central gradient of the
       input.</p></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@clone():Object" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#colorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="colorField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="colorField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colorField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@colorField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a color field from either a scalar field (with an implicit
assumption that the field represents a grayscale image) or a vector
field (with the implicit assumption that the vector field represents
the (red, green, blue) components of the color image.</p><div class="fullcomment"><div class="comment cmt"><p>Create a color field from either a scalar field (with an implicit
assumption that the field represents a grayscale image) or a vector
field (with the implicit assumption that the vector field represents
the (red, green, blue) components of the color image.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input scalar or vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>Composed color field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#colorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="colorField(red:cogx.compiler.parser.syntaxtree.Field,green:cogx.compiler.parser.syntaxtree.Field,blue:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="colorField(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">colorField</span><span class="params">(<span name="red">red: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="green">green: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="blue">blue: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@colorField(red:cogx.compiler.parser.syntaxtree.Field,green:cogx.compiler.parser.syntaxtree.Field,blue:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a color field from three scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a color field from three scalar fields.
</p></div><dl class="paramcmts block"><dt class="param">red</dt><dd class="cmt"><p>The red component scalar field.</p></dd><dt class="param">green</dt><dd class="cmt"><p>The green component scalar field.</p></dd><dt class="param">blue</dt><dd class="cmt"><p>The blue component scalar field.</p></dd><dt>returns</dt><dd class="cmt"><p>Color field composed of (red, green, blue).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#complex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="complex(real:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="complex(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">complex</span><span class="params">(<span name="real">real: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@complex(real:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a complex field from a real field.</p><div class="fullcomment"><div class="comment cmt"><p>Create a complex field from a real field.
</p></div><dl class="paramcmts block"><dt class="param">real</dt><dd class="cmt"><p>Real input scalar field.</p></dd><dt>returns</dt><dd class="cmt"><p>Complex version of real, with imaginary part set to zeros.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#complex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="complex(real:cogx.compiler.parser.syntaxtree.Field,imaginary:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="complex(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">complex</span><span class="params">(<span name="real">real: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="imaginary">imaginary: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@complex(real:cogx.compiler.parser.syntaxtree.Field,imaginary:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a complex field from two scalar fields
</p><div class="fullcomment"><div class="comment cmt"><p>Create a complex field from two scalar fields
</p></div><dl class="paramcmts block"><dt class="param">real</dt><dd class="cmt"><p>Real part of the created complex field.</p></dd><dt class="param">imaginary</dt><dd class="cmt"><p>Imaginary part of the created complex field.</p></dd><dt>returns</dt><dd class="cmt"><p>Complex field composed of the real and imaginary inputs</p></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#complexToCogComplex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="complexToCogComplex(c:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.CogComplex"></a>
      <a id="complexToCogComplex(cogmath.algebra.complex.Complex):CogComplex"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">complexToCogComplex</span><span class="params">(<span name="c">c: <a href="../cogmath/algebra/complex/Complex.html" class="extype" name="cogx.cogmath.algebra.complex.Complex">cogmath.algebra.complex.Complex</a></span>)</span><span class="result">: <span class="extype" name="cogx.compiler.parser.syntaxtree.CogComplex">CogComplex</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@complexToCogComplex(c:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.CogComplex" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Complex to a CogComplex which allows for fields
to be combined with floating point numbers in a simple way.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Complex to a CogComplex which allows for fields
to be combined with floating point numbers in a simple way.
This makes it possible to express commutative operations with a common
syntax.</p><p>For example</p><pre>Field + Complex</pre><p>and</p><pre>Complex + Field</pre><p>are both legal and compilable with this implicit conversion.
</p></div><dl class="paramcmts block"><dt class="param">c</dt><dd class="cmt"><p>The Complex to be converted to a CogComplex</p></dd><dt>returns</dt><dd class="cmt"><p>The CogComplex created from <code>c</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#complexVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="complexVectorField(fields:Array[cogx.compiler.parser.syntaxtree.ComplexField]):cogx.compiler.parser.syntaxtree.ComplexVectorField"></a>
      <a id="complexVectorField(Array[compiler.parser.syntaxtree.ComplexField]):compiler.parser.syntaxtree.ComplexVectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">complexVectorField</span><span class="params">(<span name="fields">fields: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/ComplexField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexField">compiler.parser.syntaxtree.ComplexField</a>]</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ComplexVectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexVectorField">compiler.parser.syntaxtree.ComplexVectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@complexVectorField(fields:Array[cogx.compiler.parser.syntaxtree.ComplexField]):cogx.compiler.parser.syntaxtree.ComplexVectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a complex vector field by stacking complex scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a complex vector field by stacking complex scalar fields.</p><p>For example, this can be used to stack N complex fields to a single
complex vector field where each vector is of length N.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The complex fields to be stacked into a complex vector
       field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting complex vector field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#complexVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="complexVectorField(fields:cogx.compiler.parser.syntaxtree.ComplexField*):cogx.compiler.parser.syntaxtree.ComplexVectorField"></a>
      <a id="complexVectorField(compiler.parser.syntaxtree.ComplexField*):compiler.parser.syntaxtree.ComplexVectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">complexVectorField</span><span class="params">(<span name="fields">fields: <a href="../compiler/parser/syntaxtree/ComplexField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexField">compiler.parser.syntaxtree.ComplexField</a>*</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ComplexVectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexVectorField">compiler.parser.syntaxtree.ComplexVectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@complexVectorField(fields:cogx.compiler.parser.syntaxtree.ComplexField*):cogx.compiler.parser.syntaxtree.ComplexVectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a complex vector field by stacking complex scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a complex vector field by stacking complex scalar fields.</p><p>For example, this can be used to stack N complex fields to a single
complex vector field where each vector is of length N.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The complex fields to be stacked into a complex vector
       field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting complex vector field.</p></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#complexVectorTo0DComplexVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="complexVectorTo0DComplexVectorField(v:cogx.cogmath.algebra.complex.ComplexVector):cogx.compiler.parser.syntaxtree.ComplexVectorField"></a>
      <a id="complexVectorTo0DComplexVectorField(cogmath.algebra.complex.ComplexVector):compiler.parser.syntaxtree.ComplexVectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">complexVectorTo0DComplexVectorField</span><span class="params">(<span name="v">v: <a href="../cogmath/algebra/complex/ComplexVector.html" class="extype" name="cogx.cogmath.algebra.complex.ComplexVector">cogmath.algebra.complex.ComplexVector</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ComplexVectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexVectorField">compiler.parser.syntaxtree.ComplexVectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@complexVectorTo0DComplexVectorField(v:cogx.cogmath.algebra.complex.ComplexVector):cogx.compiler.parser.syntaxtree.ComplexVectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a ComplexVector to a 0D constant ComplexVectorField
which allows for fields to be combined with ComplexVectors in a simple way.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a ComplexVector to a 0D constant ComplexVectorField
which allows for fields to be combined with ComplexVectors in a simple way.
This makes it possible to express commutative operations with a common
syntax.</p><p>For example</p><pre>Field + ComplexVector</pre><p>and</p><pre>ComplexVector + Field</pre><p>are both legal and compilable with this implicit conversion.
</p></div><dl class="paramcmts block"><dt class="param">v</dt><dd class="cmt"><p>The complex vector to be converted to a 0D complex vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>A 0D complex vector field initialized to <code>v</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#conjugate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conjugate(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="conjugate(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">conjugate</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@conjugate(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the complex conjugate of each element in a complex field
</p><div class="fullcomment"><div class="comment cmt"><p>Take the complex conjugate of each element in a complex field
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Conjugate of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#convolve" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="convolve(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="convolve(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">convolve</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="filter">filter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../package.html">NoSamplingConvolution</a></span></span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@convolve(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convolve a scalar/vector/matrix field with a filter.</p><div class="fullcomment"><div class="comment cmt"><p>Convolve a scalar/vector/matrix field with a filter.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for convolution; must be square and with
       odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling convolution along borders,
       implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       convolution, also helps to determine the size of output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field convolved with <code>filter</code> using the supplied border
       and sampling policies.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#convolveFilterAdjoint" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="convolveFilterAdjoint(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="convolveFilterAdjoint(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">convolveFilterAdjoint</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="filter">filter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../package.html">NoSamplingConvolution</a></span></span></span>, <span name="batchSize">batchSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@convolveFilterAdjoint(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convolve a vector field with a vector-field with &quot;filter adjoint&quot; plane mixing.</p><div class="fullcomment"><div class="comment cmt"><p>Convolve a vector field with a vector-field with &quot;filter adjoint&quot; plane mixing.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for convolution; must be square and with
       odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling convolution along borders,
       implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       convolution, also helps to determine the size of output field.</p></dd><dt class="param">batchSize</dt><dd class="cmt"><p>The number of logical (possibly multi-plane) images present in the input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field convolved with <code>filter</code> using the supplied border
       and sampling policies.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#convolveSeparable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="convolveSeparable(field:cogx.compiler.parser.syntaxtree.Field,rowFilter:cogx.compiler.parser.syntaxtree.Field,columnFilter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="convolveSeparable(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">convolveSeparable</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="rowFilter">rowFilter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="columnFilter">columnFilter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@convolveSeparable(field:cogx.compiler.parser.syntaxtree.Field,rowFilter:cogx.compiler.parser.syntaxtree.Field,columnFilter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convolve a scalar/vector/matrix field with a row filter and a
column filter (separable convolution).</p><div class="fullcomment"><div class="comment cmt"><p>Convolve a scalar/vector/matrix field with a row filter and a
column filter (separable convolution).
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">rowFilter</dt><dd class="cmt"><p>The filter to use for convolving the rows
       with odd size in each dimension.</p></dd><dt class="param">columnFilter</dt><dd class="cmt"><p>The filter to use for convolving the columns
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling convolution along
       borders, implicitly helps to determine size of output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field convolved with filters using the supplied
       border policy.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#copy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="copy(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="copy(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copy</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@copy(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a copy of a field.</p><div class="fullcomment"><div class="comment cmt"><p>Create a copy of a field.  This should not be used normally in a user model, but exists as a debugging tool
to help identify Cog core issues.  The Cog compiler uses this method internally between pipeline stages that
have no other computation between them.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A copy of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#cos" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cos(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="cos(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cos</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@cos(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the cosine of every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the cosine of every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       cos(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#cosh" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cosh(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="cosh(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cosh</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@cosh(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the hyperbolic cosine of every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the hyperbolic cosine of every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       cosh(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#crossCorrelate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="crossCorrelate(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="crossCorrelate(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">crossCorrelate</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="filter">filter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../package.html">NoSamplingConvolution</a></span></span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@crossCorrelate(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cross-correlate a scalar/vector/matrix field with a filter.</p><div class="fullcomment"><div class="comment cmt"><p>Cross-correlate a scalar/vector/matrix field with a filter.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for cross-correlation; must be square and
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling cross-correlation along
       borders, implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       crossCorrelation, also helps to determine the size of output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field cross-correlated with <code>filter</code> using the supplied
       border and sampling policies.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#crossCorrelateFilterAdjoint" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="crossCorrelateFilterAdjoint(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="crossCorrelateFilterAdjoint(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">crossCorrelateFilterAdjoint</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="filter">filter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../package.html">NoSamplingConvolution</a></span></span></span>, <span name="batchSize">batchSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@crossCorrelateFilterAdjoint(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cross-correlate a vector field with a vector-field with &quot;filter adjoint&quot; plane mixing.</p><div class="fullcomment"><div class="comment cmt"><p>Cross-correlate a vector field with a vector-field with &quot;filter adjoint&quot; plane mixing.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for cross-correlation; must be square and
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling cross-correlation along
       borders, implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       crossCorrelation, also helps to determine the size of output field.</p></dd><dt class="param">batchSize</dt><dd class="cmt"><p>The number of logical (possibly multi-plane) images present in the input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field cross-correlated with <code>filter</code> using the supplied
       border and sampling policies.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#crossCorrelateSeparable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="crossCorrelateSeparable(field:cogx.compiler.parser.syntaxtree.Field,rowFilter:cogx.compiler.parser.syntaxtree.Field,columnFilter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="crossCorrelateSeparable(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">crossCorrelateSeparable</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="rowFilter">rowFilter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="columnFilter">columnFilter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@crossCorrelateSeparable(field:cogx.compiler.parser.syntaxtree.Field,rowFilter:cogx.compiler.parser.syntaxtree.Field,columnFilter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cross-correlate a scalar/vector/matrix field with a row filter and a
column filter (separable convolution).</p><div class="fullcomment"><div class="comment cmt"><p>Cross-correlate a scalar/vector/matrix field with a row filter and a
column filter (separable convolution).
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">rowFilter</dt><dd class="cmt"><p>The filter to use for cross-correlating the rows
       with odd size in each dimension.</p></dd><dt class="param">columnFilter</dt><dd class="cmt"><p>The filter to use for cross-correlating the columns
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling cross-correlation along
       borders, implicitly helps to determine size of output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field cross-correlated with filters using the supplied
       border policy.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#crossDot" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="crossDot(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="crossDot(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">crossDot</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="f2">f2: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@crossDot(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Multiply a 2D matrix field, <code>field</code>, by a 2D scalar field, <code>f2</code>, to
produce a 2D scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Multiply a 2D matrix field, <code>field</code>, by a 2D scalar field, <code>f2</code>, to
produce a 2D scalar field.</p><p>The scalar field <code>f2</code> must have the same shape as the matrices in <code>field</code>.
This operator is basically pretending that the <code>f2</code> scalar field is
really a matrix and simply dotting that matrix with every matrix in the
matrix field <code>field</code>, producing a scalar in the corresponding position
of the result scalar field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">f2</dt><dd class="cmt"><p>Scalar field to multiply with <code>field</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>&quot;cross dot&quot; product of <code>field</code> and <code>f2</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#dct" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dct(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dct(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dct</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@dct(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the DCT (discrete cosine transform) of a 2D field, producing a
field with the same shape as the input.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the DCT (discrete cosine transform) of a 2D field, producing a
field with the same shape as the input.</p><p>The following sequence will return the original input, within the bounds
of computational error:</p><pre><span class="kw">val</span> field
<span class="kw">val</span> transformed: Field =
<span class="kw">val</span> restored = transformed.dctInverse
<span class="cmt">// restored is approximately equal to field</span></pre><p>For a somewhat faster version, see dctTransposed.</p><p>The DCT has several requirements:</p><p>The number of rows and columns must each be a power of 2.</p><p>Rows and columns are restricted to the range [256, 2048]
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The DCT of the input.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#dctInverse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dctInverse(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dctInverse(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dctInverse</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@dctInverse(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the inverse DCT (discrete cosine transform) of a 2D field, producing
a field with the same shape as the input.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the inverse DCT (discrete cosine transform) of a 2D field, producing
a field with the same shape as the input.</p><p>The following sequence will return the original input, within the bounds
of computational error:</p><pre><span class="kw">val</span> field
<span class="kw">val</span> transformed = field.dct
<span class="kw">val</span> restored = transformed.dctInverse
<span class="cmt">// restored is approximately equal to field</span></pre><p>For a somewhat faster version, see dctInverseTransposed.</p><p>The DCT has several requirements:</p><p>The number of rows and columns must each be a power of 2.</p><p>Rows and columns are restricted to the range [256, 2048]
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The DCT of the input.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#dctInverseTransposed" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dctInverseTransposed(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dctInverseTransposed(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dctInverseTransposed</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@dctInverseTransposed(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the inverse DCT (discrete cosine transform) of a 2D field, producing
a field with the same shape as the input.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the inverse DCT (discrete cosine transform) of a 2D field, producing
a field with the same shape as the input.</p><p>The following sequence will return the original input, within the bounds
of computational error:</p><pre><span class="kw">val</span> field
<span class="kw">val</span> transformed = field.dctTransposed
<span class="kw">val</span> restored = transformed.dctInverseTransposed
<span class="cmt">// restored is approximately equal to field</span></pre><p>This is a somewhat faster version of dctInverse where the transpose is not
important to (or can be compensated within) an application.</p><p>The DCT has several requirements:</p><p>The number of rows and columns must each be a power of 2.</p><p>Rows and columns are restricted to the range [256, 2048]
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The DCT of the input.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#dctTransposed" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dctTransposed(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dctTransposed(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dctTransposed</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@dctTransposed(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the DCT (discrete cosine transform) of a 2D field and transposes it,
producing a field with the same shape as the input transposed.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the DCT (discrete cosine transform) of a 2D field and transposes it,
producing a field with the same shape as the input transposed.</p><p>The following sequence will return the original input, within the bounds
of computational error:</p><pre><span class="kw">val</span> field
<span class="kw">val</span> transformed = field.dctTransposed
<span class="kw">val</span> restored = transformed.dctInverseTransposed
<span class="cmt">// restored is approximately equal to field</span></pre><p>This is a somewhat faster version of dct where the transpose is not
important to (or can be compensated within) an application.</p><p>The DCT has several requirements:</p><p>The number of rows and columns must each be a power of 2.</p><p>Rows and columns are restricted to the range [256, 2048]
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The DCT of the input.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#dot" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dot(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dot(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dot</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="f2">f2: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@dot(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the inner product of two identically shaped tensor fields to
create a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the inner product of two identically shaped tensor fields to
create a scalar field.</p><p>The tensors in both fields must have the same shape. Dotting two tensors
involves multiplying corresponding elements in the two tensors and
summing the products.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">f2</dt><dd class="cmt"><p>Other field to &quot;dot&quot; with <code>field</code> field.</p></dd><dt>returns</dt><dd class="cmt"><p>Scalar field where each scalar element is computed from the dot
      product of the tensors in the corresponding location of the two
      input tensor fields.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#downsample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="downsample(field:cogx.compiler.parser.syntaxtree.Field,factor:Int,phase:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="downsample(compiler.parser.syntaxtree.Field,Int,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">downsample</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="factor">factor: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">2</span></span>, <span name="phase">phase: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@downsample(field:cogx.compiler.parser.syntaxtree.Field,factor:Int,phase:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Downsample a field by taking every nth element.</p><div class="fullcomment"><div class="comment cmt"><p>Downsample a field by taking every nth element.</p><p>Example: for input field {1,2,3,4}</p><pre>input.downsample(<span class="num">2</span>) yields {<span class="num">1</span>,<span class="num">3</span>}

input.downsample(<span class="num">2</span>,<span class="num">1</span>) yields {<span class="num">2</span>,<span class="num">4</span>}</pre><p>Further examples of downsampling on a 2-dimensional input:</p><p><img src="../../doc-images/downsample.png">
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">factor</dt><dd class="cmt"><p>The sampling factor, defaults to 2.</p></dd><dt class="param">phase</dt><dd class="cmt"><p>The offset within the scaled up field to put the input
       data, defaults to an offset of 0.</p></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@eq(x$1:AnyRef):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@equals(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#exp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="exp(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="exp(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exp</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@exp(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the exponential function to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the exponential function to every numeric element in <code>field</code>. This
works for complex and real fields.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       exp(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#expand" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expand(field:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,sizes:Int*):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="expand(compiler.parser.syntaxtree.Field,platform.types.BorderPolicy,Int*):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expand</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="sizes">sizes: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@expand(field:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,sizes:Int*):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Expand an N-dimensional field by padding it with values per the border
policy, maintaining the origin.</p><div class="fullcomment"><div class="comment cmt"><p>Expand an N-dimensional field by padding it with values per the border
policy, maintaining the origin. The supported border policies are
BorderZero, BorderClamp and BorderCyclic.</p><p>See expand(borderPolicy, shape) for a description of the border policies.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for producing border values.</p></dd><dt class="param">sizes</dt><dd class="cmt"><p>The integer dimensions of the expanded output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Expanded field with new elements filled in from the nearest input
      edge per <code>borderPolicy</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#expand" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expand(field:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,shape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="expand(compiler.parser.syntaxtree.Field,platform.types.BorderPolicy,cogmath.geometry.Shape):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expand</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="shape">shape: <a href="../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@expand(field:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,shape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Expand an N-dimensional field by padding it with values per the border
policy, maintaining the origin.</p><div class="fullcomment"><div class="comment cmt"><p>Expand an N-dimensional field by padding it with values per the border
policy, maintaining the origin. The supported border policies are
BorderZero, BorderClamp and BorderCyclic.</p><p>With the BorderZero policy, the border values are all 0.</p><p>Border Zero Example. A 3 x 4 input field:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span></pre><p>If we expand this to 7 x 8, we fill the new elements with zeroes:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span></pre><p>With the BorderClamp policy, the border is extended outwards into the expanded
output field, wrapping around as though the output field were a torus.
This is useful when doing convolution with the FFT and one wishes to
minimize border effects by &quot;border clamping&quot;.</p><p>BorderClamp Example. A 3 x 4 input field:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span></pre><p>If we expand this to 7 x 8, we extend the borders, wrapping around as
though the output field were a torus:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">4</span>  <span class="num">4</span>  <span class="num">1</span>  <span class="num">1</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">6</span>  <span class="num">6</span>  <span class="num">5</span>  <span class="num">5</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">7</span>  <span class="num">7</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span></pre><p>With the BorderCyclic policy, the border values emulate a cyclic
&quot;wrap-around&quot; in the original field, as though the input field were a torus.
This is useful when doing cyclic convolution with the FFT and one wishes
expand the field to make it a power of 2 (necessary for the FFT) while
still preserving cyclic convolution</p><p>BorderCyclic Example. A 3 x 4 input field:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span></pre><p>If we expand this to 7 x 8, we extend the borders, wrapping around as
though the input field were a torus:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>
<span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span></pre></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for producing border values.</p></dd><dt class="param">shape</dt><dd class="cmt"><p>The shape of the expanded output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Expanded field with new elements filled in from the nearest input
      edge per <code>borderPolicy</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fft" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fft(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fft(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fft</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fft(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the FFT of a complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the FFT of a complex field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>FFT of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fftColumns" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftColumns(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftColumns(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftColumns</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fftColumns(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the FFT of the columns only in a 2D complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the FFT of the columns only in a 2D complex field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input with each columns transformed by the FFT.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fftInverse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftInverse(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftInverse(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftInverse</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fftInverse(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the inverse FFT of a complex field (includes scaling).</p><div class="fullcomment"><div class="comment cmt"><p>Compute the inverse FFT of a complex field (includes scaling).
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Inverse FFT of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fftInverseColumns" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftInverseColumns(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftInverseColumns(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftInverseColumns</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fftInverseColumns(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the inverseFFT of the columns only in a 2D complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the inverseFFT of the columns only in a 2D complex field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input with each columns transformed by the inverse FFT.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fftInverseRI" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftInverseRI(real:cogx.compiler.parser.syntaxtree.Field,imaginary:cogx.compiler.parser.syntaxtree.Field):(cogx.compiler.parser.syntaxtree.Field,cogx.compiler.parser.syntaxtree.Field)"></a>
      <a id="fftInverseRI(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftInverseRI</span><span class="params">(<span name="real">real: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="imaginary">imaginary: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: (<a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>, <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fftInverseRI(real:cogx.compiler.parser.syntaxtree.Field,imaginary:cogx.compiler.parser.syntaxtree.Field):(cogx.compiler.parser.syntaxtree.Field,cogx.compiler.parser.syntaxtree.Field)" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the inverse FFT of a complex field represented as separate real and imaginary fields
(includes scaling).</p><div class="fullcomment"><div class="comment cmt"><p>Compute the inverse FFT of a complex field represented as separate real and imaginary fields
(includes scaling).
</p></div><dl class="paramcmts block"><dt class="param">real</dt><dd class="cmt"><p>The real component of the complex field input.</p></dd><dt class="param">imaginary</dt><dd class="cmt"><p>The imaginary component of the complex field input.</p></dd><dt>returns</dt><dd class="cmt"><p>Inverse FFT of the input field, returned as a Tuple2 of the real and imaginary part fields.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fftInverseRows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftInverseRows(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftInverseRows(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftInverseRows</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fftInverseRows(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the inverse FFT of the rows only in a 2D complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the inverse FFT of the rows only in a 2D complex field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input with each row transformed by the inverse FFT.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fftRI" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftRI(real:cogx.compiler.parser.syntaxtree.Field):(cogx.compiler.parser.syntaxtree.Field,cogx.compiler.parser.syntaxtree.Field)"></a>
      <a id="fftRI(compiler.parser.syntaxtree.Field):(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftRI</span><span class="params">(<span name="real">real: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: (<a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>, <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fftRI(real:cogx.compiler.parser.syntaxtree.Field):(cogx.compiler.parser.syntaxtree.Field,cogx.compiler.parser.syntaxtree.Field)" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the FFT of a real field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the FFT of a real field.
</p></div><dl class="paramcmts block"><dt class="param">real</dt><dd class="cmt"><p>The real component of the input whose imaginary component is 0.</p></dd><dt>returns</dt><dd class="cmt"><p>FFT of the input, returned as a Tuple2 of the real and imaginary part fields.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fftRI" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftRI(real:cogx.compiler.parser.syntaxtree.Field,imaginary:cogx.compiler.parser.syntaxtree.Field):(cogx.compiler.parser.syntaxtree.Field,cogx.compiler.parser.syntaxtree.Field)"></a>
      <a id="fftRI(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftRI</span><span class="params">(<span name="real">real: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="imaginary">imaginary: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: (<a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>, <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fftRI(real:cogx.compiler.parser.syntaxtree.Field,imaginary:cogx.compiler.parser.syntaxtree.Field):(cogx.compiler.parser.syntaxtree.Field,cogx.compiler.parser.syntaxtree.Field)" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the FFT of a complex field that is input as two separate real and imaginary fields.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the FFT of a complex field that is input as two separate real and imaginary fields.
</p></div><dl class="paramcmts block"><dt class="param">real</dt><dd class="cmt"><p>The real component of the complex field input.</p></dd><dt class="param">imaginary</dt><dd class="cmt"><p>The imaginary component of the complex field input.</p></dd><dt>returns</dt><dd class="cmt"><p>FFT of the input, returned as a Tuple2 of the real and imaginary part fields.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fftRows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftRows(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftRows(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftRows</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fftRows(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the FFT of the rows only in a 2D complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the FFT of the rows only in a 2D complex field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input with each row transformed by the FFT.</p></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldArrayToMatrixFieldArray" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldArrayToMatrixFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.MatrixField]"></a>
      <a id="fieldArrayToMatrixFieldArray(Array[compiler.parser.syntaxtree.Field]):Array[compiler.parser.syntaxtree.MatrixField]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldArrayToMatrixFieldArray</span><span class="params">(<span name="a">a: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">compiler.parser.syntaxtree.MatrixField</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldArrayToMatrixFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.MatrixField]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of an array of Fields to an array of ScalarFields.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of an array of Fields to an array of ScalarFields.
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>An array of Fields.</p></dd><dt>returns</dt><dd class="cmt"><p>An array of MatrixFields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldArrayToScalarFieldArray" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldArrayToScalarFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.ScalarField]"></a>
      <a id="fieldArrayToScalarFieldArray(Array[compiler.parser.syntaxtree.Field]):Array[compiler.parser.syntaxtree.ScalarField]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldArrayToScalarFieldArray</span><span class="params">(<span name="a">a: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">compiler.parser.syntaxtree.ScalarField</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldArrayToScalarFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.ScalarField]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of an array of Fields to an array of ScalarFields.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of an array of Fields to an array of ScalarFields.
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>An array of Fields.</p></dd><dt>returns</dt><dd class="cmt"><p>An array of ScalarFields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldArrayToVectorFieldArray" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldArrayToVectorFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.VectorField]"></a>
      <a id="fieldArrayToVectorFieldArray(Array[compiler.parser.syntaxtree.Field]):Array[compiler.parser.syntaxtree.VectorField]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldArrayToVectorFieldArray</span><span class="params">(<span name="a">a: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldArrayToVectorFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.VectorField]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of an array of Fields to an array of ScalarFields.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of an array of Fields to an array of ScalarFields.
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>An array of Fields.</p></dd><dt>returns</dt><dd class="cmt"><p>An array of VectorFields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fieldReduceMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldReduceMax(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fieldReduceMax(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldReduceMax</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldReduceMax(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a scalar field to a 0D scalar containing a single element which
is the maximum element in the input field.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a scalar field to a 0D scalar containing a single element which
is the maximum element in the input field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>0D scalar field holding the max value in input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fieldReduceMedian" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldReduceMedian(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fieldReduceMedian(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldReduceMedian</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldReduceMedian(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Find the median value in a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Find the median value in a scalar field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>0D scalar field holding the median value of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fieldReduceMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldReduceMin(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fieldReduceMin(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldReduceMin</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldReduceMin(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a scalar field to a 0D scalar containing a single element which
is the minimum element in the input field.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a scalar field to a 0D scalar containing a single element which
is the minimum element in the input field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>0D scalar field holding the min value in input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#fieldReduceSum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldReduceSum(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fieldReduceSum(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldReduceSum</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldReduceSum(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a scalar field to a 0D scalar containing the sum of all the
elements in the input field.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a scalar field to a 0D scalar containing the sum of all the
elements in the input field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>0D scalar field holding the sum of values in input field.</p></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToColorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToColorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ColorField"></a>
      <a id="fieldToColorField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.ColorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToColorField</span><span class="params">(<span name="f">f: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ColorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ColorField">compiler.parser.syntaxtree.ColorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldToColorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ColorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a ColorField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a ColorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ColorField but stored in a Field variable. This method also
supports converting a ScalarField or VectorField to a ColorField.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the ColorField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToComplexField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToComplexField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexField"></a>
      <a id="fieldToComplexField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.ComplexField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToComplexField</span><span class="params">(<span name="f">f: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ComplexField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexField">compiler.parser.syntaxtree.ComplexField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldToComplexField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a ComplexField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a ComplexField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ComplexField but stored in a Field variable. This method also
supports converting a ScalarField to a ComplexField.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the ComplexField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToComplexVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToComplexVectorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexVectorField"></a>
      <a id="fieldToComplexVectorField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.ComplexVectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToComplexVectorField</span><span class="params">(<span name="f">f: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ComplexVectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexVectorField">compiler.parser.syntaxtree.ComplexVectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldToComplexVectorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexVectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a ComplexField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a ComplexField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ComplexField but stored in a Field variable. This method also
supports converting a ScalarField to a ComplexField.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the ComplexVectorField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToMatrixField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToMatrixField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.MatrixField"></a>
      <a id="fieldToMatrixField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.MatrixField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToMatrixField</span><span class="params">(<span name="f">f: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">compiler.parser.syntaxtree.MatrixField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldToMatrixField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.MatrixField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a MatrixField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a MatrixField. Since Field is abstract,
the only possible conversion is if the field is already a MatrixField but
is stored in a Field variable. This merely does the necessary type
coercion.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the MatrixField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToScalarField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToScalarField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ScalarField"></a>
      <a id="fieldToScalarField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.ScalarField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToScalarField</span><span class="params">(<span name="f">f: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">compiler.parser.syntaxtree.ScalarField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldToScalarField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ScalarField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a ScalarField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a ScalarField. Since Field is abstract,
the only possible conversion is if the field is already a ScalarField but
is stored in a Field variable. This merely does the necessary type
coercion.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the ScalarField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToVectorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="fieldToVectorField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToVectorField</span><span class="params">(<span name="f">f: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@fieldToVectorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a VectorField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a VectorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a VectorField but stored in a Field variable. This method also
supports converting a ColorField to a VectorField.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the VectorField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@finalize():Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#flip" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flip(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="flip(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flip</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@flip(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Flip a field along every dimension.</p><div class="fullcomment"><div class="comment cmt"><p>Flip a field along every dimension.</p><p> Example. This 2D scalar field:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>
<span class="num">4</span>  <span class="num">5</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span></pre><p> looks like this when flipped:</p><pre><span class="num">9</span>  <span class="num">8</span>  <span class="num">7</span>
<span class="num">6</span>  <span class="num">5</span>  <span class="num">4</span>
<span class="num">3</span>  <span class="num">2</span>  <span class="num">1</span></pre></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A flipped version of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#floatToCogFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="floatToCogFloat(f:Float):cogx.compiler.parser.syntaxtree.CogFloat"></a>
      <a id="floatToCogFloat(Float):CogFloat"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">floatToCogFloat</span><span class="params">(<span name="f">f: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/CogFloat.html" class="extype" name="cogx.compiler.parser.syntaxtree.CogFloat">CogFloat</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@floatToCogFloat(f:Float):cogx.compiler.parser.syntaxtree.CogFloat" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Float to a CogFloat which allows for fields
to be combined with floating point numbers in a simple way.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Float to a CogFloat which allows for fields
to be combined with floating point numbers in a simple way.
This makes it possible to express commutative operations with a common
syntax.</p><p>For example</p><pre>Field + <span class="std">Float</span></pre><p>and</p><pre><span class="std">Float</span> + Field</pre><p>are both legal and compilable with this implicit conversion.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>The Float to be converted to a CogFloat</p></dd><dt>returns</dt><dd class="cmt"><p>The CogFloat created from <code>f</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#floor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="floor(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="floor(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">floor</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@floor(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Map each numeric element of the input field to the largest integer
which is less than or equal to that element.</p><div class="fullcomment"><div class="comment cmt"><p>Map each numeric element of the input field to the largest integer
which is less than or equal to that element.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field where every number element has been &quot;floored&quot; to an integer.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#forwardGradient" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="forwardGradient(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="forwardGradient(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">forwardGradient</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@forwardGradient(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the forward gradient of a 2D scalar or vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the forward gradient of a 2D scalar or vector field.</p><p>This is the adjoint operator of backwardDivergence.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>For a scalar field input, a vector field representing the
        forward gradient of the input; for a vector input field, an
        order 4 tensor field representing the forward gradient of the
        input.</p></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@getClass():Class[_]" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@hashCode():Int" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#imaginaryPart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="imaginaryPart(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="imaginaryPart(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">imaginaryPart</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@imaginaryPart(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extract the imaginary part of a complex field as a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Extract the imaginary part of a complex field as a scalar field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, with each element
       equal to the imaginary part of the corresponding complex element in
       the input.</p></dd></dl></div>
    </li><li name="cogx.compiler.CompilerError#internalError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="internalError(message:String):Unit"></a>
      <a id="internalError(String):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">internalError</span><span class="params">(<span name="message">message: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@internalError(message:String):Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Declare an internal error described by <code>message</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Declare an internal error described by <code>message</code>.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>CompilerError</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@isInstanceOf[T0]:Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#log" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="log(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="log(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">log</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@log(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the natural logarithm to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the natural logarithm to every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       log(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#magnitude" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="magnitude(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="magnitude(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">magnitude</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@magnitude(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the magnitude of each element in a complex field
</p><div class="fullcomment"><div class="comment cmt"><p>Take the magnitude of each element in a complex field
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Magnitude of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#matrixField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="matrixField(fields:Array[Array[cogx.compiler.parser.syntaxtree.Field]]):cogx.compiler.parser.syntaxtree.MatrixField"></a>
      <a id="matrixField(Array[Array[compiler.parser.syntaxtree.Field]]):compiler.parser.syntaxtree.MatrixField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">matrixField</span><span class="params">(<span name="fields">fields: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>]]</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">compiler.parser.syntaxtree.MatrixField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@matrixField(fields:Array[Array[cogx.compiler.parser.syntaxtree.Field]]):cogx.compiler.parser.syntaxtree.MatrixField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a matrix field from a 2D array of scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a matrix field from a 2D array of scalar fields.</p><p>For example, this can be used to stack N x K scalar fields to a single
matrix field. Each matrix in the result will be N x K.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The scalar fields to be stacked into a matrix field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting matrix field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#matrixField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="matrixField(fields:Array[Array[cogx.compiler.parser.syntaxtree.ScalarField]]):cogx.compiler.parser.syntaxtree.MatrixField"></a>
      <a id="matrixField(Array[Array[compiler.parser.syntaxtree.ScalarField]]):compiler.parser.syntaxtree.MatrixField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">matrixField</span><span class="params">(<span name="fields">fields: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">compiler.parser.syntaxtree.ScalarField</a>]]</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">compiler.parser.syntaxtree.MatrixField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@matrixField(fields:Array[Array[cogx.compiler.parser.syntaxtree.ScalarField]]):cogx.compiler.parser.syntaxtree.MatrixField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a matrix field from a 2D array of scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a matrix field from a 2D array of scalar fields.</p><p>For example, this can be used to stack N x K scalar fields to a single
matrix field. Each matrix in the result will be N x K.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The scalar fields to be stacked into a matrix field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting matrix field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#matrixField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="matrixField(fields:Array[cogx.compiler.parser.syntaxtree.VectorField]):cogx.compiler.parser.syntaxtree.MatrixField"></a>
      <a id="matrixField(Array[compiler.parser.syntaxtree.VectorField]):compiler.parser.syntaxtree.MatrixField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">matrixField</span><span class="params">(<span name="fields">fields: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a>]</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">compiler.parser.syntaxtree.MatrixField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@matrixField(fields:Array[cogx.compiler.parser.syntaxtree.VectorField]):cogx.compiler.parser.syntaxtree.MatrixField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a matrix field from vector fields by &quot;stacking&quot; the vector fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a matrix field from vector fields by &quot;stacking&quot; the vector fields.</p><p>For example, this can be used to stack N vector fields to a single matrix
field. If the length of the vectors in the vector fields is K, then
each matrix in the result will be N x K.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The vector fields to be stacked into a matrix field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting matrix field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#matrixField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="matrixField(fields:cogx.compiler.parser.syntaxtree.VectorField*):cogx.compiler.parser.syntaxtree.MatrixField"></a>
      <a id="matrixField(compiler.parser.syntaxtree.VectorField*):compiler.parser.syntaxtree.MatrixField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">matrixField</span><span class="params">(<span name="fields">fields: <a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a>*</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">compiler.parser.syntaxtree.MatrixField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@matrixField(fields:cogx.compiler.parser.syntaxtree.VectorField*):cogx.compiler.parser.syntaxtree.MatrixField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a matrix field from vector fields by &quot;stacking&quot; the vector fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a matrix field from vector fields by &quot;stacking&quot; the vector fields.</p><p>For example, this can be used to stack N vector fields to a single matrix
field. If the length of the vectors in the vector fields is K, then
each matrix in the result will be N x K.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The vector fields to be stacked into a matrix field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting matrix field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#matrixRow" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="matrixRow(field:cogx.compiler.parser.syntaxtree.Field,index:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="matrixRow(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">matrixRow</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="index">index: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@matrixRow(field:cogx.compiler.parser.syntaxtree.Field,index:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convert a matrix field to a vector field by stripping out one row
from each matrix in the field and making it a vector.</p><div class="fullcomment"><div class="comment cmt"><p>Convert a matrix field to a vector field by stripping out one row
from each matrix in the field and making it a vector.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">index</dt><dd class="cmt"><p>The index of the desired row to strip out of each matrix
       and use as a vector.</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field made up of the stripped out vectors from the
       input matrix field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#max" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="max(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="max(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">max</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="f2">f2: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@max(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Select the maximum value of corresponding elements in two scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Select the maximum value of corresponding elements in two scalar fields.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">f2</dt><dd class="cmt"><p>Second scalar field to compare with <code>field</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Scalar field where each element is the largest corresponding
       elements in <code>field</code> or <code>f2</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#max" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="max(field:cogx.compiler.parser.syntaxtree.Field,value:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="max(compiler.parser.syntaxtree.Field,Float):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">max</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="value">value: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@max(field:cogx.compiler.parser.syntaxtree.Field,value:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>field</code>, compute <code>max(x, that)</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>field</code>, compute <code>max(x, that)</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>filed</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">value</dt><dd class="cmt"><p>Operand for max operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>field</code> with each element, <code>x</code>, mapped to
        <code>max(x, that)</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#min" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="min(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="min(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">min</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="f2">f2: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@min(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Select the minimum value of corresponding elements in two scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Select the minimum value of corresponding elements in two scalar fields.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">f2</dt><dd class="cmt"><p>Second scalar field to compare with <code>field</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Scalar field where each element is the smallest corresponding
       elements in <code>field</code> or <code>f2</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#min" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="min(field:cogx.compiler.parser.syntaxtree.Field,value:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="min(compiler.parser.syntaxtree.Field,Float):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">min</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="value">value: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@min(field:cogx.compiler.parser.syntaxtree.Field,value:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>field</code>, compute <code>min(x, that)</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>field</code>, compute <code>min(x, that)</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">value</dt><dd class="cmt"><p>Operand for min operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>field</code> with each element, <code>x</code>, mapped to
        <code>min(x, that)</code>.</p></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@ne(x$1:AnyRef):Boolean" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#normalizeL1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="normalizeL1(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="normalizeL1(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">normalizeL1</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@normalizeL1(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Normalize a scalar field using the L1 norm.</p><div class="fullcomment"><div class="comment cmt"><p>Normalize a scalar field using the L1 norm.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A normalized copy of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#normalizeL2" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="normalizeL2(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="normalizeL2(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">normalizeL2</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@normalizeL2(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Normalize a scalar field using the L2 norm.</p><div class="fullcomment"><div class="comment cmt"><p>Normalize a scalar field using the L2 norm.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A normalized copy of the input field.</p></dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@notify():Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@notifyAll():Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#phase" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="phase(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="phase(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">phase</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@phase(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the phase of each element in a complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Take the phase of each element in a complex field.</p><p>This is also commonly called <code>arg</code>. This is a number in the range
(-Pi, Pi]
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Phase of the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#polarComplex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="polarComplex(magnitude:cogx.compiler.parser.syntaxtree.Field,phase:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="polarComplex(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">polarComplex</span><span class="params">(<span name="magnitude">magnitude: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="phase">phase: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@polarComplex(magnitude:cogx.compiler.parser.syntaxtree.Field,phase:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a complex field from polar coordinates.</p><div class="fullcomment"><div class="comment cmt"><p>Create a complex field from polar coordinates.
</p></div><dl class="paramcmts block"><dt class="param">magnitude</dt><dd class="cmt"><p>Scalar field where each scalar is the magnitude of the
       desired complex field.</p></dd><dt class="param">phase</dt><dd class="cmt"><p>Scalar field where each scalar is the phase of the
       desired complex field.</p></dd><dt>returns</dt><dd class="cmt"><p>Complex field built from magnitude and phase.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#pow" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pow(field:cogx.compiler.parser.syntaxtree.Field,that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="pow(compiler.parser.syntaxtree.Field,Float):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pow</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@pow(field:cogx.compiler.parser.syntaxtree.Field,that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Raise each number in <code>field</code>  to the power <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Raise each number in <code>field</code>  to the power <code>that</code>.
The resulting field has the same field shape and tensor shape as <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">that</dt><dd class="cmt"><p>The exponent.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field with every number raised to the power <code>that</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#pow" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pow(field:cogx.compiler.parser.syntaxtree.Field,that:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="pow(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pow</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="that">that: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@pow(field:cogx.compiler.parser.syntaxtree.Field,that:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Raise each number in <code>field</code> to the power <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Raise each number in <code>field</code> to the power <code>that</code>.
The resulting field has the same field shape and tensor shape as <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">that</dt><dd class="cmt"><p>The exponent.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field with every number raised to the power <code>that</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#probe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="probe(fields:cogx.compiler.parser.syntaxtree.Field*):Unit"></a>
      <a id="probe(compiler.parser.syntaxtree.Field*):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">probe</span><span class="params">(<span name="fields">fields: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>*</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@probe(fields:cogx.compiler.parser.syntaxtree.Field*):Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">User mechanism for marking multiple fields as &quot;probed&quot;</p><div class="fullcomment"><div class="comment cmt"><p>User mechanism for marking multiple fields as &quot;probed&quot;</p><p>If a field is visible to reflection, it will be automatically named.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The fields to be probed.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#probe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="probe(field:cogx.compiler.parser.syntaxtree.Field,userName:String):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="probe(compiler.parser.syntaxtree.Field,String):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">probe</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="userName">userName: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">null</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@probe(field:cogx.compiler.parser.syntaxtree.Field,userName:String):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">User mechanism for marking a field as &quot;probed,&quot; optionally supplying a
name for the field.</p><div class="fullcomment"><div class="comment cmt"><p>User mechanism for marking a field as &quot;probed,&quot; optionally supplying a
name for the field.</p><p>If a field is visible to reflection, it will be automatically named.
In that case supplying a <code>userName</code> is unnecessary and not recommended.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The field to be probed.</p></dd><dt class="param">userName</dt><dd class="cmt"><p>User's name for the field. If not supplied, the field is
       probed but uses system-inferred naming for the field.</p></dd><dt>returns</dt><dd class="cmt"><p>The field being probed.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#projectFrame" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="projectFrame(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="projectFrame(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">projectFrame</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="filter">filter: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../package.html">NoSamplingConvolution</a></span></span></span>, <span name="batchSize">batchSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@projectFrame(field:cogx.compiler.parser.syntaxtree.Field,filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cross-correlate a vector field with a vector-field filter frame.</p><div class="fullcomment"><div class="comment cmt"><p>Cross-correlate a vector field with a vector-field filter frame.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for cross-correlation; must be square and
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling cross-correlation along
       borders, implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       crossCorrelation, also helps to determine the size of output field.</p></dd><dt class="param">batchSize</dt><dd class="cmt"><p>The number of logical (possibly multi-plane) images present in the input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field cross-correlated with <code>filter</code> using the supplied
       border and sampling policies.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#random" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="random(field:cogx.compiler.parser.syntaxtree.Field,bits:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="random(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">random</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="bits">bits: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@random(field:cogx.compiler.parser.syntaxtree.Field,bits:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute a random field based on this input field using cellular
automaton based RNG.</p><div class="fullcomment"><div class="comment cmt"><p>Compute a random field based on this input field using cellular
automaton based RNG. The output ranges from [0 to 1] (inclusive) and is
uniformly distributed.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">bits</dt><dd class="cmt"><p>The number of bits of precision to use</p></dd><dt>returns</dt><dd class="cmt"><p>A Vector field where each point in the field is random</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#realPart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="realPart(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="realPart(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">realPart</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@realPart(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extract the real part of a complex field as a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Extract the real part of a complex field as a scalar field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, with each element
       equal to the real part of the corresponding complex element in the
       input.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#reciprocal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reciprocal(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reciprocal(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reciprocal</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@reciprocal(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform 1/x operation on every numeric element of a field.</p><div class="fullcomment"><div class="comment cmt"><p>Perform 1/x operation on every numeric element of a field.</p><p>Somewhat dangerous to use if any element in the field could be zero, since
the resulting element would be NaN which does not throw an exception.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field with each numeric element, x, mapped to 1/x.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#reduceMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduceMax(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reduceMax(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceMax</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@reduceMax(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a scalar field by mapping each vector to the
maximum of its components.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a scalar field by mapping each vector to the
maximum of its components.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with each element equal to the maximum of
       the components of the corresponding vector in the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#reduceMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduceMin(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reduceMin(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceMin</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@reduceMin(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a scalar field by mapping each vector to the
minimum of its components.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a scalar field by mapping each vector to the
minimum of its components.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with each element equal to the minimum of
       the components of the corresponding vector in the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#reduceSum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduceSum(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reduceSum(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceSum</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@reduceSum(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a scalar field by mapping each vector to the
sum of its components.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a scalar field by mapping each vector to the
sum of its components.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with each element equal to the sum of components of
       the corresponding vector in the input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#replicate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="replicate(field:cogx.compiler.parser.syntaxtree.Field,shape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="replicate(compiler.parser.syntaxtree.Field,cogmath.geometry.Shape):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">replicate</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="shape">shape: <a href="../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@replicate(field:cogx.compiler.parser.syntaxtree.Field,shape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Replicate a scalar field as matrices in a matrix field (each matrix in
the matrix field is identical to the input scalar field).</p><div class="fullcomment"><div class="comment cmt"><p>Replicate a scalar field as matrices in a matrix field (each matrix in
the matrix field is identical to the input scalar field).
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">shape</dt><dd class="cmt"><p>The shape of the resulting output field.</p></dd><dt>returns</dt><dd class="cmt"><p>A matrix field with the same field shape as <code>f2</code> and tensor
       shape the same as the input scalar field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#reshape" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reshape(field:cogx.compiler.parser.syntaxtree.Field,fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,checkLegacyReshape:Boolean):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reshape(compiler.parser.syntaxtree.Field,cogmath.geometry.Shape,cogmath.geometry.Shape,Boolean):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reshape</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="fieldShape">fieldShape: <a href="../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="tensorShape">tensorShape: <a href="../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="checkLegacyReshape">checkLegacyReshape: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol"><span class="name"><a href="../package.html">Cog.checkLegacyReshape</a></span></span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@reshape(field:cogx.compiler.parser.syntaxtree.Field,fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,checkLegacyReshape:Boolean):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Change the shape of a scalar field without changing the number of
elements in it.</p><div class="fullcomment"><div class="comment cmt"><p>Change the shape of a scalar field without changing the number of
elements in it.</p><p>This depends on the row-major ordering we use for elements in a field.
Elements in any scalar field, regardless of dimension, have that linear
ordering. Reshaping preserves that ordering; it really does nothing
more than change the sizes of each dimension of the field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">fieldShape</dt><dd class="cmt"><p>the output field shape to use</p></dd><dt class="param">tensorShape</dt><dd class="cmt"><p>the output tensor shape to use</p></dd><dt class="param">checkLegacyReshape</dt><dd class="cmt"><p>Warn of uses of reshape that had different behaviors prior to libcog 4.3</p></dd><dt>returns</dt><dd class="cmt"><p>The input field, reshaped, with the same elements in the same
       linear order.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#reshape" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reshape(field:cogx.compiler.parser.syntaxtree.Field,size:Int*):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reshape(compiler.parser.syntaxtree.Field,Int*):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reshape</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="size">size: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@reshape(field:cogx.compiler.parser.syntaxtree.Field,size:Int*):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Change the shape of a scalar field without changing the number of
elements in it.</p><div class="fullcomment"><div class="comment cmt"><p>Change the shape of a scalar field without changing the number of
elements in it.</p><p>This depends on the row-major ordering we use for elements in a field.
Elements in any scalar field, regardless of dimension, have that linear
ordering. Reshaping preserves that ordering; it really does nothing
more than change the sizes of each dimension of the field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">size</dt><dd class="cmt"><p>A sequence of new sizes for each dimensions. The product of
       this sequence must equal the number of elements in the input
       field.</p></dd><dt>returns</dt><dd class="cmt"><p>The input field, reshaped, with the same elements in the same
       linear order.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#reverseCrossDot" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reverseCrossDot(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reverseCrossDot(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reverseCrossDot</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="f2">f2: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@reverseCrossDot(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Multiply a matrix field, <code>field</code>, by a scalar field, <code>f2</code>, to produce a
scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Multiply a matrix field, <code>field</code>, by a scalar field, <code>f2</code>, to produce a
scalar field.</p><p>The matrix field and scalar field operands must have identical field
shapes. Each scalar element of the scalar field is multiplied by the
corresponding element in the matrix field. These products are then
summed to produce the scalar field result (which has the same shape as
the matrices in the matrix field).
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">f2</dt><dd class="cmt"><p>Scalar field operand which have the same field shape as
       <code>field</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Product of <code>field</code> and <code>f2</code>.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#select" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="select[T&lt;:cogx.compiler.parser.syntaxtree.Field](fields:Array[T],index:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="select[T&lt;:compiler.parser.syntaxtree.Field](Array[T],compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">select</span><span class="tparams">[<span name="T">T &lt;: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>]</span><span class="params">(<span name="fields">fields: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="cogx.api.CogFunctionAPI.select.T">T</span>]</span>, <span name="index">index: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@select[T&lt;:cogx.compiler.parser.syntaxtree.Field](fields:Array[T],index:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Dynamically select a scalar field from an array of scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Dynamically select a scalar field from an array of scalar fields.</p><p>Example:</p><pre><span class="kw">val</span> fields: <span class="std">Array</span>[ScalarFieldExpr] = ...
<span class="kw">val</span> index: ScalarFieldExpr
<span class="kw">val</span> selected: ScalarFieldExpr = select(fields, index)</pre></div><dl class="paramcmts block"><dt class="param">index</dt><dd class="cmt"><p>0-dimensional scalar field supplying the index for the
       array to be read.</p></dd><dt>returns</dt><dd class="cmt"><p>If index is in-bounds for the array, returns the selected field
       from that array; if index is out-of-bounds, returns a field of
       NaNs.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#shift" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shift(field:cogx.compiler.parser.syntaxtree.Field,rowShift:Int,colShift:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="shift(compiler.parser.syntaxtree.Field,Int,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shift</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="rowShift">rowShift: <span class="extype" name="scala.Int">Int</span></span>, <span name="colShift">colShift: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@shift(field:cogx.compiler.parser.syntaxtree.Field,rowShift:Int,colShift:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shift a 2D scalar field in both dimensions, pulling in zeroes where
necessary.</p><div class="fullcomment"><div class="comment cmt"><p>Shift a 2D scalar field in both dimensions, pulling in zeroes where
necessary. Negative shift amounts result in shifts up and to the left,
while positive shift amounts result in shifts down and to the right.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">rowShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt class="param">colShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt>returns</dt><dd class="cmt"><p>Shifted input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#shift" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shift(field:cogx.compiler.parser.syntaxtree.Field,colShift:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="shift(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shift</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="colShift">colShift: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@shift(field:cogx.compiler.parser.syntaxtree.Field,colShift:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shift a 1D scalar field left (negative <code>colShift</code>) or right (positive
<code>colShift</code>), pulling in zeroes where necessary.</p><div class="fullcomment"><div class="comment cmt"><p>Shift a 1D scalar field left (negative <code>colShift</code>) or right (positive
<code>colShift</code>), pulling in zeroes where necessary.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">colShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt>returns</dt><dd class="cmt"><p>Shifted input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#shiftCyclic" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shiftCyclic(field:cogx.compiler.parser.syntaxtree.Field,rowShift:Int,colShift:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="shiftCyclic(compiler.parser.syntaxtree.Field,Int,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shiftCyclic</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="rowShift">rowShift: <span class="extype" name="scala.Int">Int</span></span>, <span name="colShift">colShift: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@shiftCyclic(field:cogx.compiler.parser.syntaxtree.Field,rowShift:Int,colShift:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shift a 2D scalar field in both dimensions, pulling in values from the opposite
side where necessary.</p><div class="fullcomment"><div class="comment cmt"><p>Shift a 2D scalar field in both dimensions, pulling in values from the opposite
side where necessary. Negative shift amounts result in shifts up and to the
left, while positive shift amounts result in shifts down and to the right.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">rowShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt class="param">colShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt>returns</dt><dd class="cmt"><p>Shifted input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#shiftCyclic" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shiftCyclic(field:cogx.compiler.parser.syntaxtree.Field,colShift:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="shiftCyclic(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shiftCyclic</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="colShift">colShift: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@shiftCyclic(field:cogx.compiler.parser.syntaxtree.Field,colShift:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shift a 1D scalar field left (negative <code>colShift</code>) or right (positive
<code>colShift</code>), pulling in values from the opposite side where necessary.</p><div class="fullcomment"><div class="comment cmt"><p>Shift a 1D scalar field left (negative <code>colShift</code>) or right (positive
<code>colShift</code>), pulling in values from the opposite side where necessary.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">colShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt>returns</dt><dd class="cmt"><p>Shifted input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#signum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="signum(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="signum(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">signum</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@signum(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the signum operator to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the signum operator to every numeric element in <code>field</code>.</p><p>Signum(x) is defined to be:</p><p> 1 if x &gt; 0</p><p> 0 if x: Field =</p><p>-1 if x &lt; 0
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       signum(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#sin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sin(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="sin(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sin</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@sin(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the sine operator to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the sine operator to every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       sin(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#sinh" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sinh(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="sinh(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sinh</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@sinh(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the hyperbolic sine operator to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the hyperbolic sine operator to every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       sinh(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#solve" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="solve(field:cogx.compiler.parser.syntaxtree.Field,b:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="solve(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">solve</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="b">b: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@solve(field:cogx.compiler.parser.syntaxtree.Field,b:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Solve Ax - b</p><div class="fullcomment"><div class="comment cmt"><p>Solve Ax - b</p><p>This actually solves the equation for each matrix / vector pair in the
fields <code>field</code> and <code>b</code>, producing a vector field representing x. The
vectors in b must be length 2 and the matrices in <code>field</code> must be 2 x 2.
Solves the equations using the pseudo inverse
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">b</dt><dd class="cmt"><p>Vector field argument.</p></dd><dt>returns</dt><dd class="cmt"><p>The solution, x, to the set of linear equations.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#sq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sq(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="sq(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sq</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@sq(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the square operator to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the square operator to every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       (x * x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#sqrt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sqrt(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="sqrt(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqrt</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@sqrt(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the square root operator to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the square root operator to every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       sqrt(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#stack" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stack[T&lt;:cogx.compiler.parser.syntaxtree.Field](fields:Array[T]):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="stack[T&lt;:compiler.parser.syntaxtree.Field](Array[T]):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stack</span><span class="tparams">[<span name="T">T &lt;: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>]</span><span class="params">(<span name="fields">fields: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="cogx.api.CogFunctionAPI.stack.T">T</span>]</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@stack[T&lt;:cogx.compiler.parser.syntaxtree.Field](fields:Array[T]):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Stack tensor fields to create a higher-order tensor field.</p><div class="fullcomment"><div class="comment cmt"><p>Stack tensor fields to create a higher-order tensor field.</p><p>For example, this can be used to stack N scalar fields to a single vector
field where each vector is of length N.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The fields to be stacked.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting, higher-order tensor field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#stack" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stack(fields:cogx.compiler.parser.syntaxtree.Field*):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="stack(compiler.parser.syntaxtree.Field*):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stack</span><span class="params">(<span name="fields">fields: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>*</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@stack(fields:cogx.compiler.parser.syntaxtree.Field*):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Stack tensor fields to create a higher-order tensor field.</p><div class="fullcomment"><div class="comment cmt"><p>Stack tensor fields to create a higher-order tensor field.</p><p>For example, this can be used to stack N scalar fields to a single vector
field where each vector is of length N.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The fields to be stacked.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting, higher-order tensor field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#subfield" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subfield(field:cogx.compiler.parser.syntaxtree.Field,guide:cogx.compiler.parser.syntaxtree.Field,shape:cogx.cogmath.geometry.Shape,border:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="subfield(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,cogmath.geometry.Shape,platform.types.BorderPolicy):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subfield</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="guide">guide: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="shape">shape: <a href="../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="border">border: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span> = <span class="symbol"><span class="name"><a href="../package.html">BorderClamp</a></span></span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@subfield(field:cogx.compiler.parser.syntaxtree.Field,guide:cogx.compiler.parser.syntaxtree.Field,shape:cogx.cogmath.geometry.Shape,border:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extracts a window from a 1D or 2D scalar, vector or matrix field, guided by
a 0D vector field called &quot;the guide.&quot; The guide specifies the upper-left-most
(or left-most for 1D fields) point of the window, and <code>shape</code>
specifies the size of the window.</p><div class="fullcomment"><div class="comment cmt"><p>Extracts a window from a 1D or 2D scalar, vector or matrix field, guided by
a 0D vector field called &quot;the guide.&quot; The guide specifies the upper-left-most
(or left-most for 1D fields) point of the window, and <code>shape</code>
specifies the size of the window.</p><p>A guiding vector with value (v1, v2) means a given point (row, col) extracts
the element at location (row + v1, col + v2) as its output. If that location
falls outside of the field, the BorderPolicy attached to the the opcode
determines how the missing value is computed. If either of the guide vector
components v1 and v2 is non-integral, bilinear interpolation is used to
to determine the approximate value.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">guide</dt><dd class="cmt"><p>The guide vector.</p></dd><dt class="param">shape</dt><dd class="cmt"><p>Shape of the window.</p></dd><dt class="param">border</dt><dd class="cmt"><p>Policy for handling border processing.</p></dd><dt>returns</dt><dd class="cmt"><p>Extracted window.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#subfields" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subfields(field:cogx.compiler.parser.syntaxtree.Field,diameter:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="subfields(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subfields</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="diameter">diameter: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@subfields(field:cogx.compiler.parser.syntaxtree.Field,diameter:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extract all subfields from a 2D scalar field into a 2-D vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Extract all subfields from a 2D scalar field into a 2-D vector field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">diameter</dt><dd class="cmt"><p>Sizes (rows and columns) of each subfield. Must be odd.</p></dd><dt>returns</dt><dd class="cmt"><p>A 2-D vector field where the length of the vector equals the
       number of <code>diameter</code> x <code>diameter</code> subfields in the input.
       For example, a 4 x 4 input field has four subfields of size 3 x 3,
       so this operator would return a 2-D vector field of size 3 x 3
       (the size of the subfields) with vectors of length 4.
       Each layer of the vector field is one subfield of of the input.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#supersample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="supersample(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="supersample(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">supersample</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@supersample(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Supersample a scalar field by 2X in each dimension, replicating pixels
to fill in the gaps.</p><div class="fullcomment"><div class="comment cmt"><p>Supersample a scalar field by 2X in each dimension, replicating pixels
to fill in the gaps.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field expanded by 2X in each dimension with pixel
replication.</p></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@synchronized[T0](x$1:=&gt;T0):T0" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#tan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tan(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="tan(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tan</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@tan(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the tangent operator to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the tangent operator to every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       tan(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#tanh" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tanh(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="tanh(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tanh</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@tanh(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the hyperbolic tangent operator to every numeric element in <code>field</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the hyperbolic tangent operator to every numeric element in <code>field</code>.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       tanh(x).</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#toColorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toColorField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ColorField"></a>
      <a id="toColorField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.ColorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toColorField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ColorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ColorField">compiler.parser.syntaxtree.ColorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@toColorField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ColorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a ColorField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a ColorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ColorField but stored in a Field variable. This method also
supports converting a ScalarField or VectorField to a ColorField.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#toComplexField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toComplexField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexField"></a>
      <a id="toComplexField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.ComplexField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toComplexField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ComplexField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexField">compiler.parser.syntaxtree.ComplexField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@toComplexField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a ComplexField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a ComplexField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ComplexField but stored in a Field variable. This method also
supports converting a ScalarField to a ComplexField.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#toComplexVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toComplexVectorField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexVectorField"></a>
      <a id="toComplexVectorField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.ComplexVectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toComplexVectorField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ComplexVectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexVectorField">compiler.parser.syntaxtree.ComplexVectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@toComplexVectorField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexVectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a ComplexVectorField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a ComplexVectorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ComplexVectorField but stored in a Field variable. This method also
supports converting a VectorField to a ComplexVectorField.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#toGenericComplexField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toGenericComplexField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="toGenericComplexField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toGenericComplexField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@toGenericComplexField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Another explicit conversion, this time working on both ScalarFields and
VectorFields.</p><div class="fullcomment"><div class="comment cmt"><p>Another explicit conversion, this time working on both ScalarFields and
VectorFields. The return type is Field though, the common base class of
both ComplexFields and ComplexScalarFields.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#toMatrixField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toMatrixField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.MatrixField"></a>
      <a id="toMatrixField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.MatrixField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMatrixField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">compiler.parser.syntaxtree.MatrixField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@toMatrixField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.MatrixField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a MatrixField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a MatrixField. Since Field is abstract,
the only possible conversion is if the field is already a MatrixField but
is stored in a Field variable. This merely does the necessary type
coercion.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#toScalarField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toScalarField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ScalarField"></a>
      <a id="toScalarField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.ScalarField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalarField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">compiler.parser.syntaxtree.ScalarField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@toScalarField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ScalarField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a ScalarField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a ScalarField. Since Field is abstract,
the only possible conversion is if the field is already a ScalarField but
is stored in a Field variable. This merely does the necessary type
coercion.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@toString():String" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#toVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toVectorField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="toVectorField(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toVectorField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@toVectorField(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a VectorField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a VectorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a VectorField but stored in a Field variable. This method also
supports converting a ColorField to a VectorField.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#transform" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transform(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="transform(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transform</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="f2">f2: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@transform(field:cogx.compiler.parser.syntaxtree.Field,f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">(1) Multiply a matrix field by a matrix field to produce a matrix field; or
(2) multiply a matrix field by a vector field to produce a vector field.</p><div class="fullcomment"><div class="comment cmt"><p>(1) Multiply a matrix field by a matrix field to produce a matrix field; or
(2) multiply a matrix field by a vector field to produce a vector field.</p><p>For case (1), corresponding matrices in <code>field</code> and <code>f2</code> are multiplied
using standard matrix multiplication to produce the corresponding matrix
in the resulting matrix field.</p><p>For case (2), corresponding matrix/vector pari in <code>field</code> and <code>f2</code> are
multiplied using standard matrix/vector multiplication to produce the
corresponding vector (a linear transformation of the input vector)
in the resulting vector field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">f2</dt><dd class="cmt"><p>Matrix field or vector field; must have the same field shape
      as <code>field</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Matrix field or vector representing the matrix multiplications of
      corresponding elements in the two input fields.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#transpose" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transpose(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="transpose(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transpose</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@transpose(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Transpose a 2D tensor field or color field.</p><div class="fullcomment"><div class="comment cmt"><p>Transpose a 2D tensor field or color field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#transposeMatrices" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transposeMatrices(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="transposeMatrices(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transposeMatrices</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@transposeMatrices(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Transpose all the matrices in a matrix field to produce a new matrix
field.</p><div class="fullcomment"><div class="comment cmt"><p>Transpose all the matrices in a matrix field to produce a new matrix
field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Copy of input matrix field with all matrices transposed.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#transposeVectors" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transposeVectors(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="transposeVectors(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transposeVectors</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@transposeVectors(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Transpose each vector in a vector field to a single row matrix, thus
creating a matrix field from a vector field
</p><div class="fullcomment"><div class="comment cmt"><p>Transpose each vector in a vector field to a single row matrix, thus
creating a matrix field from a vector field
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Copy of input matrix field with all vectors transposed to
       single row matrices.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#trim" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="trim(field:cogx.compiler.parser.syntaxtree.Field,resultShape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="trim(compiler.parser.syntaxtree.Field,cogmath.geometry.Shape):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">trim</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="resultShape">resultShape: <a href="../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@trim(field:cogx.compiler.parser.syntaxtree.Field,resultShape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">&quot;Trim&quot; a field to a smaller size by clipping off indices (maintaining the
origin).</p><div class="fullcomment"><div class="comment cmt"><p>&quot;Trim&quot; a field to a smaller size by clipping off indices (maintaining the
origin).
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">resultShape</dt><dd class="cmt"><p>Desired shape of the resulting field; must not be
       larger in any dimension than the corresponding dimension of the
       input field</p></dd><dt>returns</dt><dd class="cmt"><p>The trimmed field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#upsample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="upsample(field:cogx.compiler.parser.syntaxtree.Field,factor:Int,phase:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="upsample(compiler.parser.syntaxtree.Field,Int,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">upsample</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="factor">factor: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">2</span></span>, <span name="phase">phase: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@upsample(field:cogx.compiler.parser.syntaxtree.Field,factor:Int,phase:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Upsample with zeroes inserted between field points, increasing
the size of the input in all dimensions.</p><div class="fullcomment"><div class="comment cmt"><p>Upsample with zeroes inserted between field points, increasing
the size of the input in all dimensions.</p><p>Example: for input field {1,2,3}</p><pre>input.upsample(<span class="num">2</span>) yields {<span class="num">1</span>,<span class="num">0</span>,<span class="num">2</span>,<span class="num">0</span>,<span class="num">3</span>,<span class="num">0</span>}

input.upsample(<span class="num">2</span>,<span class="num">1</span>) yields {<span class="num">0</span>,<span class="num">1</span>,<span class="num">0</span>,<span class="num">2</span>,<span class="num">0</span>,<span class="num">3</span>}</pre></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">factor</dt><dd class="cmt"><p>The sampling factor, defaults to 2.</p></dd><dt class="param">phase</dt><dd class="cmt"><p>The offset within the scaled up field to put the input
       data, defaults to an offset of 0.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#vectorElement" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorElement(field:cogx.compiler.parser.syntaxtree.Field,index:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="vectorElement(compiler.parser.syntaxtree.Field,Int):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorElement</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="index">index: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@vectorElement(field:cogx.compiler.parser.syntaxtree.Field,index:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convert a vector field to a scalar field by extracting one element of each
vector.</p><div class="fullcomment"><div class="comment cmt"><p>Convert a vector field to a scalar field by extracting one element of each
vector.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">index</dt><dd class="cmt"><p>The element of each vector to be extracted.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field with tensor order reduced by one.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#vectorElements" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorElements(field:cogx.compiler.parser.syntaxtree.Field,indices:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="vectorElements(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorElements</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="indices">indices: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@vectorElements(field:cogx.compiler.parser.syntaxtree.Field,indices:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convert a vector field to a smaller vector field by extracting a dynamically
indexed a range of elements
</p><div class="fullcomment"><div class="comment cmt"><p>Convert a vector field to a smaller vector field by extracting a dynamically
indexed a range of elements
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field with tensor order reduced by one.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#vectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorField(field:cogx.compiler.parser.syntaxtree.ColorField):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="vectorField(compiler.parser.syntaxtree.ColorField):compiler.parser.syntaxtree.VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorField</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/ColorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ColorField">compiler.parser.syntaxtree.ColorField</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@vectorField(field:cogx.compiler.parser.syntaxtree.ColorField):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convert a color field to a vector field, with each vector of length
3 representing, in order, the red, green and blue components of the
corresponding pixel.</p><div class="fullcomment"><div class="comment cmt"><p>Convert a color field to a vector field, with each vector of length
3 representing, in order, the red, green and blue components of the
corresponding pixel.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>Color field to be converted to vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>Vector field, with each vector holding the red, green, blue
       components.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#vectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorField(fields:Array[cogx.compiler.parser.syntaxtree.Field]):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="vectorField(Array[compiler.parser.syntaxtree.Field]):compiler.parser.syntaxtree.VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorField</span><span class="params">(<span name="fields">fields: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a>]</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@vectorField(fields:Array[cogx.compiler.parser.syntaxtree.Field]):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a vector field from scalar fields by &quot;stacking&quot; the scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a vector field from scalar fields by &quot;stacking&quot; the scalar fields.</p><p>For example, this can be used to stack N scalar fields to a single vector
field where each vector is of length N.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The scalar fields to be stacked into a vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting vector field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#vectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorField(fields:Array[cogx.compiler.parser.syntaxtree.ScalarField]):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="vectorField(Array[compiler.parser.syntaxtree.ScalarField]):compiler.parser.syntaxtree.VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorField</span><span class="params">(<span name="fields">fields: <span class="extype" name="scala.Array">Array</span>[<a href="../compiler/parser/syntaxtree/ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">compiler.parser.syntaxtree.ScalarField</a>]</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@vectorField(fields:Array[cogx.compiler.parser.syntaxtree.ScalarField]):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a vector field from scalar fields by &quot;stacking&quot; the scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a vector field from scalar fields by &quot;stacking&quot; the scalar fields.</p><p>For example, this can be used to stack N scalar fields to a single vector
field where each vector is of length N.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The scalar fields to be stacked into a vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting vector field.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#vectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorField(fields:cogx.compiler.parser.syntaxtree.ScalarField*):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="vectorField(compiler.parser.syntaxtree.ScalarField*):compiler.parser.syntaxtree.VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorField</span><span class="params">(<span name="fields">fields: <a href="../compiler/parser/syntaxtree/ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">compiler.parser.syntaxtree.ScalarField</a>*</span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@vectorField(fields:cogx.compiler.parser.syntaxtree.ScalarField*):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a vector field from scalar fields by &quot;stacking&quot; the scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Create a vector field from scalar fields by &quot;stacking&quot; the scalar fields.</p><p>For example, this can be used to stack N scalar fields to a single vector
field where each vector is of length N.
</p></div><dl class="paramcmts block"><dt class="param">fields</dt><dd class="cmt"><p>The scalar fields to be stacked into a vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting vector field.</p></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#vectorTo0DVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorTo0DVectorField(v:cogx.cogmath.algebra.real.Vector):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="vectorTo0DVectorField(cogmath.algebra.real.Vector):compiler.parser.syntaxtree.VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorTo0DVectorField</span><span class="params">(<span name="v">v: <a href="../cogmath/algebra/real/Vector.html" class="extype" name="cogx.cogmath.algebra.real.Vector">cogmath.algebra.real.Vector</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">compiler.parser.syntaxtree.VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@vectorTo0DVectorField(v:cogx.cogmath.algebra.real.Vector):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Vector to a 0D constant VectorField which allows
for fields to be combined with vectors in a simple way.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Vector to a 0D constant VectorField which allows
for fields to be combined with vectors in a simple way.
This makes it possible to express commutative operations with a common
syntax.</p><p>For example</p><pre>Field + Vector</pre><p>and</p><pre>Vector + Field</pre><p>are both legal and compilable with this implicit conversion.
</p></div><dl class="paramcmts block"><dt class="param">v</dt><dd class="cmt"><p>The vector to be converted to a 0D vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>A 0D vector field initialized to <code>v</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@wait():Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@wait(x$1:Long,x$2:Int):Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@wait(x$1:Long):Unit" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#warp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="warp(field:cogx.compiler.parser.syntaxtree.Field,guide:cogx.compiler.parser.syntaxtree.Field,border:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="warp(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,platform.types.BorderPolicy):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">warp</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="guide">guide: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="border">border: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span> = <span class="symbol"><span class="name"><a href="../package.html">BorderClamp</a></span></span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@warp(field:cogx.compiler.parser.syntaxtree.Field,guide:cogx.compiler.parser.syntaxtree.Field,border:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Warps a 2D scalar, vector or matrix field, guided by a vector field
called &quot;the guide.&quot; The guide must either be zero-dimensional, in which
case the input field is translated uniformly, or must be a 2D vector
field with exactly the same shape as the input.</p><div class="fullcomment"><div class="comment cmt"><p>Warps a 2D scalar, vector or matrix field, guided by a vector field
called &quot;the guide.&quot; The guide must either be zero-dimensional, in which
case the input field is translated uniformly, or must be a 2D vector
field with exactly the same shape as the input.</p><p>The guiding vector with value (v1, v2) at a given point (row, col) extracts
the element at location (row - v1, col - v2) as its output. If that location
falls outside of the field, the BorderPolicy attached to the the opcode
determines how the missing value is computed. If either of the guide vector
components v1 and v2 is non-integral, bilinear interpolation is used to
to determine the approximate value.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">guide</dt><dd class="cmt"><p>The guiding vector field.</p></dd><dt class="param">border</dt><dd class="cmt"><p>Policy for handling borders.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field, warped by the guide.</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#winnerTakeAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="winnerTakeAll(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="winnerTakeAll(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">winnerTakeAll</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@winnerTakeAll(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the &quot;winner&quot; of a scalar field by mapping its largest element
to 1.0f and the other elements to 0.0f</p><div class="fullcomment"><div class="comment cmt"><p>Compute the &quot;winner&quot; of a scalar field by mapping its largest element
to 1.0f and the other elements to 0.0f</p><p>This is not well-defined when multiple elements share the maximum value,
so beware.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, with a single
       element containing 1.0f and the rest containing 0.0f.</p></dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="cogx.api.CogFunctionAPI#bilateralFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bilateralFilter(field:cogx.compiler.parser.syntaxtree.Field,spatialFilter:cogx.cogmath.algebra.real.Matrix,rangeSigma:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="bilateralFilter(compiler.parser.syntaxtree.Field,cogmath.algebra.real.Matrix,Float):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) inefficient, use domain transform filter instead">bilateralFilter</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="spatialFilter">spatialFilter: <a href="../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>, <span name="rangeSigma">rangeSigma: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@bilateralFilter(field:cogx.compiler.parser.syntaxtree.Field,spatialFilter:cogx.cogmath.algebra.real.Matrix,rangeSigma:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform bilateral filtering using <code>spatialFilter</code> for spatial filtering
(typically this will be a truncated Gaussian) and a Gaussian with
width <code>rangeSigma</code> for range filtering.</p><div class="fullcomment"><div class="comment cmt"><p>Perform bilateral filtering using <code>spatialFilter</code> for spatial filtering
(typically this will be a truncated Gaussian) and a Gaussian with
width <code>rangeSigma</code> for range filtering.</p><p>WARNING: This is an old algorithm that is not very efficient. Consider
a newer algorithm such as domain transform filtering.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> inefficient, use domain transform filter instead</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#conditionNumber" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conditionNumber(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="conditionNumber(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">conditionNumber</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@conditionNumber(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Given a matrix field, compute the condition number for each matrix in
that field.</p><div class="fullcomment"><div class="comment cmt"><p>Given a matrix field, compute the condition number for each matrix in
that field. This is currently limited to fields containing 2 x 2 matrices.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Scalar field holding the condition numbers for the corresponding
        matrices in the input matrix field.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#determinant" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="determinant(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="determinant(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">determinant</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@determinant(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the determinant of every matrix in a matrix field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the determinant of every matrix in a matrix field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Scalar field holding the determinants for the corresponding
        matrices in the input matrix field.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#domainFilterColumns" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="domainFilterColumns(field:cogx.compiler.parser.syntaxtree.Field,domainTransform:cogx.compiler.parser.syntaxtree.ScalarField,boxFilterRadius:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="domainFilterColumns(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.ScalarField,Float):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">domainFilterColumns</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="domainTransform">domainTransform: <a href="../compiler/parser/syntaxtree/ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">compiler.parser.syntaxtree.ScalarField</a></span>, <span name="boxFilterRadius">boxFilterRadius: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@domainFilterColumns(field:cogx.compiler.parser.syntaxtree.Field,domainTransform:cogx.compiler.parser.syntaxtree.ScalarField,boxFilterRadius:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform a &quot;domain filter&quot; on the columns of a color field as a step in
edge-aware normalized convolution.</p><div class="fullcomment"><div class="comment cmt"><p>Perform a &quot;domain filter&quot; on the columns of a color field as a step in
edge-aware normalized convolution. This &quot;correlates&quot; an adaptive box
filter with each pixel in the columns of the color field, guided by
<code>domainTransform</code>.</p><p>This operation works only on color fields and is an optimization. The
following code sequences, A and B, are functionally identical:</p><pre><span class="cmt">// Prepare for filtering</span>
<span class="kw">val</span> rowTransform: Field =
<span class="kw">val</span> colTransform: Field =

<span class="cmt">// Sequence A (slower)</span>
<span class="kw">var</span> smooth = colorImage
smooth = smooth.domainFilterRows(rowTransform, ...)
smooth = smooth.transpose.domainFilterRows(colTransform, ...).transpose

<span class="cmt">// Sequence B, using this operation (faster, no transposes)</span>
<span class="kw">var</span> smooth = colorImage
smooth = smooth.domainFilterRows(rowTransform, ...)
smooth = smooth.domainFilterColumns(colTransform, ...)</pre><p>For details, see the paper &quot;Domain transform
for edge-aware image and video processing,&quot; Gastal and Oliveira, 2011.
Normally this is not useful for end-users, but you're welcome to try it
if you would like to write your own edge-aware filters.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">domainTransform</dt><dd class="cmt"><p>The cumulative domain transform for the image.</p></dd><dt class="param">boxFilterRadius</dt><dd class="cmt"><p>Radius of box filter.</p></dd><dt>returns</dt><dd class="cmt"><p>The domain transform of the columns (equation 11) in the
        Gastal paper as a scalar field.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#domainFilterRows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="domainFilterRows(field:cogx.compiler.parser.syntaxtree.Field,domainTransform:cogx.compiler.parser.syntaxtree.Field,boxFilterRadius:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="domainFilterRows(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field,Float):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">domainFilterRows</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="domainTransform">domainTransform: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="boxFilterRadius">boxFilterRadius: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@domainFilterRows(field:cogx.compiler.parser.syntaxtree.Field,domainTransform:cogx.compiler.parser.syntaxtree.Field,boxFilterRadius:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform a &quot;domain filter&quot; on the rows of a tensor or color field as a step
in edge-aware normalized convolution.</p><div class="fullcomment"><div class="comment cmt"><p>Perform a &quot;domain filter&quot; on the rows of a tensor or color field as a step
in edge-aware normalized convolution. This &quot;correlates&quot; an adaptive box
filter with each pixel in the rows of the color field, guided by
<code>domainTransform</code>.</p><p>For details, see the paper &quot;Domain transform
for edge-aware image and video processing,&quot; Gastal and Oliveira, 2011.
Normally this is not useful for end-users, but you're welcome to try it
if you would like to write your own edge-aware filters.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">domainTransform</dt><dd class="cmt"><p>The cumulative domain transform for the image.</p></dd><dt class="param">boxFilterRadius</dt><dd class="cmt"><p>Radius of box filter.</p></dd><dt>returns</dt><dd class="cmt"><p>The domain transform of the rows (equation 11) in the
        Gastal paper as a scalar field.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#domainTransformRows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="domainTransformRows(field:cogx.compiler.parser.syntaxtree.Field,spaceSigma:Float,rangeSigma:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="domainTransformRows(compiler.parser.syntaxtree.Field,Float,Float):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">domainTransformRows</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="spaceSigma">spaceSigma: <span class="extype" name="scala.Float">Float</span></span>, <span name="rangeSigma">rangeSigma: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@domainTransformRows(field:cogx.compiler.parser.syntaxtree.Field,spaceSigma:Float,rangeSigma:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform a &quot;domain transform&quot; on the rows of a color field or tensor field
as a step in edge-aware normalized convolution.</p><div class="fullcomment"><div class="comment cmt"><p>Perform a &quot;domain transform&quot; on the rows of a color field or tensor field
as a step in edge-aware normalized convolution.</p><p>For details, see the paper &quot;Domain transform
for edge-aware image and video processing,&quot; Gastal and Oliveira, 2011.
Normally this is not useful for end-users, but you're welcome to try it
if you would like to write your own edge-aware filters.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">spaceSigma</dt><dd class="cmt"><p>Width of filter in space.</p></dd><dt class="param">rangeSigma</dt><dd class="cmt"><p>Width of filter in range.</p></dd><dt>returns</dt><dd class="cmt"><p>The domain transform of the rows (equation 11) in the
        Gastal paper as a scalar field.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#invertMatrices" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="invertMatrices(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="invertMatrices(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">invertMatrices</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@invertMatrices(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Invert all matrices in a matrix field using Gauss-Jordan elimination.</p><div class="fullcomment"><div class="comment cmt"><p>Invert all matrices in a matrix field using Gauss-Jordan elimination.</p><p>This is numerically stable only for small matrices, and let's not even
get in to singular matrices. Be careful.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A matrix field where each matrix is the (approximate) inverse of
        the corresponding matrix in the input matrix field.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#localMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localMax(field:cogx.compiler.parser.syntaxtree.Field,neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="localMax(compiler.parser.syntaxtree.Field,cogmath.algebra.real.Matrix):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">localMax</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="neighborhood">neighborhood: <a href="../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@localMax(field:cogx.compiler.parser.syntaxtree.Field,neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Find the local maximum of a neighborhood centered on each pixel in a 2D
scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Find the local maximum of a neighborhood centered on each pixel in a 2D
scalar field.</p><p>For each point in the input 2D scalar field, this searches a small
neighborhood of that point and extracts the largest scalar found.</p><p>The <code>neighborhood</code> is defined by a matrix which is centered on the point. A
non-zero value in the kernel means the corresponding point in the field
is part of the neighborhood, while a zero implies the point should be
ignored.</p><p>For example, the kernel</p><pre><span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">0</span> <span class="num">0</span> <span class="num">0</span></pre><p>specifies the 2 x 2 neighborhood for the maximum value search.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">neighborhood</dt><dd class="cmt"><p>An odd-sized matrix describing the neighborhood for
       doing the local max search. TO DO: This will become a field rather
       than a matrix. XXX</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, where each
       element is equal to the local max of the input field as defined
       by <code>neighborhood</code>.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#localMaxPosition" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localMaxPosition(field:cogx.compiler.parser.syntaxtree.Field,neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="localMaxPosition(compiler.parser.syntaxtree.Field,cogmath.algebra.real.Matrix):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">localMaxPosition</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="neighborhood">neighborhood: <a href="../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@localMaxPosition(field:cogx.compiler.parser.syntaxtree.Field,neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For a scalar field, find the relative position of the local maximum of a
neighborhood centered on the current pixel.</p><div class="fullcomment"><div class="comment cmt"><p>For a scalar field, find the relative position of the local maximum of a
neighborhood centered on the current pixel. This is returned as vector
field, with each vector's tail at the current pixel and the head pointing
at the pixel containing the neighborhood's local maximum.</p><p>The <code>neighborhood</code> is defined by a matrix which is centered on the point. A
non-zero value in the kernel means the corresponding point in the field
is part of the neighborhood, while a zero implies the point should be
ignored.</p><p>For example, the kernel</p><pre><span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">0</span> <span class="num">0</span> <span class="num">0</span></pre><p>specifies the 2 x 2 neighborhood for the maximum value search.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">neighborhood</dt><dd class="cmt"><p>An odd-sized matrix describing the neighborhood for
       doing the local max search. TO DO: This will become a field rather
       than a matrix. XXX</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field with the same field shape as the input scalar
       field, with each vector pointing to the maximum value in the
       neighborhood relative to the center of the neighborhood.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#localMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localMin(field:cogx.compiler.parser.syntaxtree.Field,neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="localMin(compiler.parser.syntaxtree.Field,cogmath.algebra.real.Matrix):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">localMin</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="neighborhood">neighborhood: <a href="../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@localMin(field:cogx.compiler.parser.syntaxtree.Field,neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Find the local minimum of a neighborhood centered on each pixel in a 2D
scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Find the local minimum of a neighborhood centered on each pixel in a 2D
scalar field.</p><p>For each point in the input 2D scalar field, this searches a small
neighborhood of that point and extracts the smallest scalar found.</p><p>The <code>neighborhood</code> is defined by a matrix which is centered on the point. A
non-zero value in the kernel means the corresponding point in the field
is part of the neighborhood, while a zero implies the point should be
ignored.</p><p>For example, the kernel</p><pre><span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">0</span> <span class="num">0</span> <span class="num">0</span></pre><p>specifies the 2 x 2 neighborhood for the minimum value search.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">neighborhood</dt><dd class="cmt"><p>An odd-sized matrix describing the neighborhood for
       doing the local max search. TO DO: This will become a field rather
       than a matrix. XXX</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, where each
       element is equal to the local min of the input field as defined
       by <code>neighborhood</code>.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#localMinPosition" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localMinPosition(field:cogx.compiler.parser.syntaxtree.Field,neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="localMinPosition(compiler.parser.syntaxtree.Field,cogmath.algebra.real.Matrix):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">localMinPosition</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="neighborhood">neighborhood: <a href="../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@localMinPosition(field:cogx.compiler.parser.syntaxtree.Field,neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For a scalar field, find the relative position of the local minimum of a
neighborhood centered on the current pixel.</p><div class="fullcomment"><div class="comment cmt"><p>For a scalar field, find the relative position of the local minimum of a
neighborhood centered on the current pixel. This is returned as vector
field, with each vector's tail at the current pixel and the head pointing
at the pixel containing the neighborhood's local manimum.</p><p>The <code>neighborhood</code> is defined by a matrix which is centered on the point. A
non-zero value in the kernel means the corresponding point in the field
is part of the neighborhood, while a zero implies the point should be
ignored.</p><p>For example, the kernel</p><pre><span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">0</span> <span class="num">0</span> <span class="num">0</span></pre><p>specifies the 2 x 2 neighborhood for the minimum value search.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">neighborhood</dt><dd class="cmt"><p>An odd-sized matrix describing the neighborhood for
       doing the local min search. TO DO: This will become a field rather
       than a matrix. XXX</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field with the same field shape as the input scalar
       field, with each vector pointing to the minimum value in the
       neighborhood relative to the center of the neighborhood.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#maxPosition" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="maxPosition(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="maxPosition(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">maxPosition</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@maxPosition(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Find the location/position of the maximum element in a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Find the location/position of the maximum element in a scalar field.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A 0D vector field containing a vector holding the indices of the
       maximum element.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#medianFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="medianFilter(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="medianFilter(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">medianFilter</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@medianFilter(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Filter a 2D input scalar field with a 3 x 3 median filter.</p><div class="fullcomment"><div class="comment cmt"><p>Filter a 2D input scalar field with a 3 x 3 median filter.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A 2D scalar field with the same field shape as the input, with
       each element median filtered.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#nonMaximumSuppression" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nonMaximumSuppression(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="nonMaximumSuppression(compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">nonMaximumSuppression</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@nonMaximumSuppression(field:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Forces locally non-maximum pixels to zero for both scalar fields and
vector fields.</p><div class="fullcomment"><div class="comment cmt"><p>Forces locally non-maximum pixels to zero for both scalar fields and
vector fields.</p><p>Locality is defined to be the 8 nearest neighbors to a given pixel. If a
pixel is greater than or equal to any of those neighbors, its value is
left intact on the output, otherwise it's set to zero. Note that border
pixels have only 5 nearest neighbors and corner pixels have only 3 nearest
neighbors, so those are the only ones checked.</p><p>Vector fields are treated as though they were an array of scalar fields,
so non-maximum suppression is executed independently on each.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt>returns</dt><dd class="cmt"><p>A copy of the input field with locally non-maximum values set to
       zero.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li><li name="cogx.api.CogFunctionAPI#orientedNonMaximumSuppression" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="orientedNonMaximumSuppression(field:cogx.compiler.parser.syntaxtree.Field,orientation:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="orientedNonMaximumSuppression(compiler.parser.syntaxtree.Field,compiler.parser.syntaxtree.Field):compiler.parser.syntaxtree.Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 4.1.1) will be moved to a library">orientedNonMaximumSuppression</span><span class="params">(<span name="field">field: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>, <span name="orientation">orientation: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>)</span><span class="result">: <a href="../compiler/parser/syntaxtree/Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">compiler.parser.syntaxtree.Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../index.html#cogx.api.CogFunctionAPI@orientedNonMaximumSuppression(field:cogx.compiler.parser.syntaxtree.Field,orientation:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Forces locally non-maximum pixels to zero for calar fields,
but only when comparing the pixels on either side of
a given pixel, using <code>orientation</code> to define where to look for the
two pixels for comparison.</p><div class="fullcomment"><div class="comment cmt"><p>Forces locally non-maximum pixels to zero for calar fields,
but only when comparing the pixels on either side of
a given pixel, using <code>orientation</code> to define where to look for the
two pixels for comparison.
</p></div><dl class="paramcmts block"><dt class="param">field</dt><dd class="cmt"><p>The input field.</p></dd><dt class="param">orientation</dt><dd class="cmt"><p>A scalar field holding the local orientation of the
       input field at every point. Orientation ranges from -Pi/2 to Pi/2,
       where the corresponding orientation rotates clockwise from
      horizontal (-Pi/2) to vertical (0) to horizontal (Pi/2).</p></dd><dt>returns</dt><dd class="cmt"><p>A copy of the input field with locally non-maximum values set to
       zero.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 4.1.1)</i> will be moved to a library</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="cogx.api.ImplicitConversions">
              <h3>Inherited from <a href="ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></h3>
            </div><div class="parent" name="cogx.compiler.parser.semantics.SemanticError">
              <h3>Inherited from <span class="extype" name="cogx.compiler.parser.semantics.SemanticError">SemanticError</span></h3>
            </div><div class="parent" name="cogx.compiler.CompilerError">
              <h3>Inherited from <span class="extype" name="cogx.compiler.CompilerError">CompilerError</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
