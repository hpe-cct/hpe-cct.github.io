<!DOCTYPE html >
<html>
        <head>
          <title>UnpipelinedVectorSensor - cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor</title>
          <meta name="description" content="UnpipelinedVectorSensor - cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor" />
          <meta name="keywords" content="UnpipelinedVectorSensor cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../../index.html';
            var hash = 'cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img alt="Class" src="../../../../lib/class_big.png" />
        <p id="owner"><a href="../../../package.html" class="extype" name="cogx">cogx</a>.<a href="../../package.html" class="extype" name="cogx.compiler">compiler</a>.<a href="../package.html" class="extype" name="cogx.compiler.parser">parser</a>.<a href="package.html" class="extype" name="cogx.compiler.parser.syntaxtree">syntaxtree</a></p>
        <h1>UnpipelinedVectorSensor</h1><h3><span class="morelinks"><div>Related Doc:
            <a href="package.html" class="extype" name="cogx.compiler.parser.syntaxtree">package syntaxtree</a>
          </div></span></h3><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">UnpipelinedVectorSensor</span><span class="result"> extends <a href="VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">VectorField</a> with <span class="extype" name="cogx.compiler.parser.semantics.SemanticError">SemanticError</span> with <a href="RestoreHooks.html" class="extype" name="cogx.compiler.parser.syntaxtree.RestoreHooks">RestoreHooks</a></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Inputs to a Cog computation are called sensors.  This implements the unpipelined vector version.</p><p>Sensors can be either pipelined or unpipelined.  Pipelined sensors use the CPU to produce
an input to the GPU while the GPU is working on the previous input.  Thus, there's
effectively a pipeline stage between the CPU and the GPU and both do their work in parallel.
Unpipelined sensors have no such pipeline stage, so the CPU must provide its input first
before the GPU processes that input further, i.e. the CPU and GPU do their work in series.</p><p>When an unpipelined sensor's nextValue method is called, it must always return an iterator
over the next input's data.  However, a pipelined sensor has the option of returning None,
if no new input is available.  In that case the pipeline register that the sensor is feeding
is not clocked and the same data is presented to the GPU.  This can be used to decouple a slow
sensor from a fast-running simulation, making the sensor appear effectively 'asynchronous'.</p><p>Both sensor types can accept a resetHook method, which can be used for example to go back to
frame-0 of a movie that's played out from a file, or to start over from the first image of a
training set.  If a sensor supplies no nextValue iterator upon reset, an all-0 field will be supplied.</p><p>Finally, sensors can be throttled back to a specified simulation rate by the '<code>desiredFramesPerSecond</code>
parameter.  This ensures that a movie is played out at the appropriate speed, for example.</p><p>Both types of sensors supply their next input by <code>nextValue</code> function which (optionally) returns an
iterator of the values of the new input in row-major order.</p><p>NOTE: if the user wishes to optimize input using, for example, multiple threads or double-buffering,
that must be done in the implementation of the function <code>nextValue</code>.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="RestoreHooks.html" class="extype" name="cogx.compiler.parser.syntaxtree.RestoreHooks">RestoreHooks</a>, <a href="VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">VectorField</a>, <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a>, <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a>, <span class="extype" name="cogx.platform.types.FieldParameters">FieldParameters</span>, <a href="FieldName.html" class="extype" name="cogx.compiler.parser.syntaxtree.FieldName">FieldName</a>, <a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a>, <span class="extype" name="cogx.compiler.parser.syntaxtree.RecurrenceTrait">RecurrenceTrait</span>, <span class="extype" name="cogx.compiler.parser.semantics.SemanticError">SemanticError</span>, <span class="extype" name="cogx.compiler.CompilerError">CompilerError</span>, <span class="extype" name="cogx.cogmath.hypercircuit.Hyperedge">Hyperedge</span>[<span class="extype" name="cogx.compiler.parser.syntaxtree.Operation">Operation</span>], <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor"><span>UnpipelinedVectorSensor</span></li><li class="in" name="cogx.compiler.parser.syntaxtree.RestoreHooks"><span>RestoreHooks</span></li><li class="in" name="cogx.compiler.parser.syntaxtree.VectorField"><span>VectorField</span></li><li class="in" name="cogx.compiler.parser.syntaxtree.Field"><span>Field</span></li><li class="in" name="cogx.api.CogOperatorAPI"><span>CogOperatorAPI</span></li><li class="in" name="cogx.platform.types.FieldParameters"><span>FieldParameters</span></li><li class="in" name="cogx.compiler.parser.syntaxtree.FieldName"><span>FieldName</span></li><li class="in" name="cogx.api.ImplicitConversions"><span>ImplicitConversions</span></li><li class="in" name="cogx.compiler.parser.syntaxtree.RecurrenceTrait"><span>RecurrenceTrait</span></li><li class="in" name="cogx.compiler.parser.semantics.SemanticError"><span>SemanticError</span></li><li class="in" name="cogx.compiler.CompilerError"><span>CompilerError</span></li><li class="in" name="cogx.cogmath.hypercircuit.Hyperedge"><span>Hyperedge</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,nextValue:()=&gt;Iterator[cogx.cogmath.algebra.real.Vector]):cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor"></a>
      <a id="&lt;init&gt;:UnpipelinedVectorSensor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">UnpipelinedVectorSensor</span><span class="params">(<span name="fieldShape">fieldShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="tensorShape">tensorShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="nextValue">nextValue: () ⇒ <span class="extype" name="scala.Iterator">Iterator</span>[<a href="../../../cogmath/algebra/real/Vector.html" class="extype" name="cogx.cogmath.algebra.real.Vector">cogmath.algebra.real.Vector</a>]</span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;init&gt;(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,nextValue:()=&gt;Iterator[cogx.cogmath.algebra.real.Vector]):cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a vector sensor of the given field and tensor Shapes with no reset hook and no frames-per-second pacing.</p>
    </li><li name="cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,nextValue:()=&gt;Iterator[cogx.cogmath.algebra.real.Vector],desiredFramesPerSecond:Double):cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor"></a>
      <a id="&lt;init&gt;:UnpipelinedVectorSensor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">UnpipelinedVectorSensor</span><span class="params">(<span name="fieldShape">fieldShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="tensorShape">tensorShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="nextValue">nextValue: () ⇒ <span class="extype" name="scala.Iterator">Iterator</span>[<a href="../../../cogmath/algebra/real/Vector.html" class="extype" name="cogx.cogmath.algebra.real.Vector">cogmath.algebra.real.Vector</a>]</span>, <span name="desiredFramesPerSecond">desiredFramesPerSecond: <span class="extype" name="scala.Double">Double</span></span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;init&gt;(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,nextValue:()=&gt;Iterator[cogx.cogmath.algebra.real.Vector],desiredFramesPerSecond:Double):cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a vector sensor of the given field and tensor Shapes with no reset hook.</p>
    </li><li name="cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,nextValue:()=&gt;Iterator[cogx.cogmath.algebra.real.Vector],resetHook:()=&gt;Unit):cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor"></a>
      <a id="&lt;init&gt;:UnpipelinedVectorSensor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">UnpipelinedVectorSensor</span><span class="params">(<span name="fieldShape">fieldShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="tensorShape">tensorShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="nextValue">nextValue: () ⇒ <span class="extype" name="scala.Iterator">Iterator</span>[<a href="../../../cogmath/algebra/real/Vector.html" class="extype" name="cogx.cogmath.algebra.real.Vector">cogmath.algebra.real.Vector</a>]</span>, <span name="resetHook">resetHook: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;init&gt;(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,nextValue:()=&gt;Iterator[cogx.cogmath.algebra.real.Vector],resetHook:()=&gt;Unit):cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a vector sensor of the given field and tensor Shapes with no frames-per-second pacing.</p>
    </li><li name="cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,nextValue:()=&gt;Iterator[cogx.cogmath.algebra.real.Vector],resetHook:()=&gt;Unit,desiredFramesPerSecond:Double):cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor"></a>
      <a id="&lt;init&gt;:UnpipelinedVectorSensor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">UnpipelinedVectorSensor</span><span class="params">(<span name="fieldShape">fieldShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="tensorShape">tensorShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="nextValue">nextValue: () ⇒ <span class="extype" name="scala.Iterator">Iterator</span>[<a href="../../../cogmath/algebra/real/Vector.html" class="extype" name="cogx.cogmath.algebra.real.Vector">cogmath.algebra.real.Vector</a>]</span>, <span name="resetHook">resetHook: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="desiredFramesPerSecond">desiredFramesPerSecond: <span class="extype" name="scala.Double">Double</span></span>)</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;init&gt;(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,nextValue:()=&gt;Iterator[cogx.cogmath.algebra.real.Vector],resetHook:()=&gt;Unit,desiredFramesPerSecond:Double):cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Create a sensor of the given Shape.</p>
    </li></ol>
            </div>

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@!=(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#!===" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!===(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="!===(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq$eq$eq" class="name">!===</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@!===(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>x notIdenticallyEquals that</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>x notIdenticallyEquals that</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for !=== operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>x notIdenticallyEquals that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#!===" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!===(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="!===(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq$eq$eq" class="name">!===</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@!===(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compare two fields using the &quot;not identically equal&quot; operator; a numeric
value of 1.0f represents true (first operand != second operand) and a
numeric value of 0.0f represents false.</p><div class="fullcomment"><div class="comment cmt"><p>Compare two fields using the &quot;not identically equal&quot; operator; a numeric
value of 1.0f represents true (first operand != second operand) and a
numeric value of 0.0f represents false.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for computing <code>this</code> !=== <code>that</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> notIdenticallyEqualTo <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@##():Int" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#%" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="%(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="%(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $percent" class="name">%</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@%(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>x modulo that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>x modulo that</code>. The result
has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for modulo operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>x modulo that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#%" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="%(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="%(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $percent" class="name">%</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@%(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute <code>this</code> modulo <code>that</code> to create a third field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute <code>this</code> modulo <code>that</code> to create a third field.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for computing <code>this</code> modulo <code>that</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> % <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#*" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="*(that:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="*(cogmath.algebra.complex.Complex):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $times" class="name">*</span><span class="params">(<span name="that">that: <a href="../../../cogmath/algebra/complex/Complex.html" class="extype" name="cogx.cogmath.algebra.complex.Complex">cogmath.algebra.complex.Complex</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@*(that:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Multiply every element in <code>this</code> by <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Multiply every element in <code>this</code> by <code>that</code>. This will coerce
<code>this</code> to be complex before proceeding.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Multiplicand</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to the product of <code>this</code> and <code>that</code>, where
        every numeric component of <code>this</code> has been multiplied by <code>that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#*" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="*(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="*(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $times" class="name">*</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@*(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Multiply every element in <code>this</code> by <code>that</code> to produce a result
with the same field shape and tensor shape as <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Multiply every element in <code>this</code> by <code>that</code> to produce a result
with the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Constant to be multiplied with every number in <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to the product of <code>this</code> and <code>that</code>, where
        every numeric component of <code>this</code> has been multiplied by <code>that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#*" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="*(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="*(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $times" class="name">*</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@*(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Multiply <code>this</code> field by <code>that</code> field to create a third field.</p><div class="fullcomment"><div class="comment cmt"><p>Multiply <code>this</code> field by <code>that</code> field to create a third field.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Field to be multiplied by <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> * <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#+" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="+(that:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="+(cogmath.algebra.complex.Complex):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus" class="name">+</span><span class="params">(<span name="that">that: <a href="../../../cogmath/algebra/complex/Complex.html" class="extype" name="cogx.cogmath.algebra.complex.Complex">cogmath.algebra.complex.Complex</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@+(that:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Add the constant <code>that</code> to every element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Add the constant <code>that</code> to every element in <code>this</code>. This will coerce
<code>this</code> to be complex before proceeding.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Constant to be added to number in <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to the sum of <code>this</code> and <code>that</code>, where <code>that</code> has
        been added to every numeric component of <code>this</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#+" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="+(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="+(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus" class="name">+</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@+(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Add the constant <code>that</code> to every element in <code>this</code> to produce a result
with the same field shape and tensor shape as <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Add the constant <code>that</code> to every element in <code>this</code> to produce a result
with the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Constant to be added to every number in <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to the sum of <code>this</code> and <code>that</code>, where <code>that</code> has
        been added to every numeric component of <code>this</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#+" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="+(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="+(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus" class="name">+</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@+(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Add <code>this</code> field and <code>that</code> field to create a third field.</p><div class="fullcomment"><div class="comment cmt"><p>Add <code>this</code> field and <code>that</code> field to create a third field.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Field to be added to <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Sum of the two fields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#-" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="-(that:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="-(cogmath.algebra.complex.Complex):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $minus" class="name">-</span><span class="params">(<span name="that">that: <a href="../../../cogmath/algebra/complex/Complex.html" class="extype" name="cogx.cogmath.algebra.complex.Complex">cogmath.algebra.complex.Complex</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@-(that:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Subtract the constant <code>that</code> from every element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Subtract the constant <code>that</code> from every element in <code>this</code>. This will coerce
<code>this</code> to be complex before proceeding.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Constant to be subtracted from each number in <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to the difference of <code>this</code> and <code>that</code>, where <code>that</code>
        has been subtracted from every numeric component of <code>this</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#-" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="-(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="-(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $minus" class="name">-</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@-(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Subtract the constant <code>that</code> from every element in <code>this</code> to produce a
result with the same field shape and tensor shape as <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Subtract the constant <code>that</code> from every element in <code>this</code> to produce a
result with the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Constant to be sutracted from every number in <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to the difference of <code>this</code> and <code>that</code>, where <code>that</code>
        has been subtracted from every numeric component of <code>this</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#-" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="-(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="-(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $minus" class="name">-</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@-(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Subtract <code>that</code> field from <code>this</code> field to create a third field.</p><div class="fullcomment"><div class="comment cmt"><p>Subtract <code>that</code> field from <code>this</code> field to create a third field.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Field to be subtracted to <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> - <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#/" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="/(that:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="/(cogmath.algebra.complex.Complex):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $div" class="name">/</span><span class="params">(<span name="that">that: <a href="../../../cogmath/algebra/complex/Complex.html" class="extype" name="cogx.cogmath.algebra.complex.Complex">cogmath.algebra.complex.Complex</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@/(that:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Divide every element in <code>this</code> by <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Divide every element in <code>this</code> by <code>that</code>. This will coerce
<code>this</code> to be complex before proceeding.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Divisor.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to the quotient of <code>this</code> and <code>that</code>, where
        every numeric component of <code>this</code> has been divided by <code>that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#/" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="/(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="/(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $div" class="name">/</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@/(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Divide every element in <code>this</code> by <code>that</code> to produce a result
with the same field shape and tensor shape as <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Divide every element in <code>this</code> by <code>that</code> to produce a result
with the same field shape and tensor shape as <code>this</code>.</p><p>The user must assure that the divisor is not zero, since the result would
be NaN which does not throw an exception.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Divisor.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> dividedBy <code>that</code>, where
        every numeric component of <code>this</code> has been divided by <code>that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#/" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="/(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="/(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $div" class="name">/</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@/(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Divide <code>this</code> field by <code>that</code> field to create a third field.</p><div class="fullcomment"><div class="comment cmt"><p>Divide <code>this</code> field by <code>that</code> field to create a third field.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Field that <code>this</code> will be divided by.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> / <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#&lt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="&lt;(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less" class="name">&lt;</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>x lessThan that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>x lessThan that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for &lt; operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>x lessThan that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#&lt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="&lt;(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less" class="name">&lt;</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compare two fields using the &quot;less than&quot; operator; a numeric value of 1.0f
represents true (first operand &lt; second operand) and a numeric value of
0.0f represents false.</p><div class="fullcomment"><div class="comment cmt"><p>Compare two fields using the &quot;less than&quot; operator; a numeric value of 1.0f
represents true (first operand &lt; second operand) and a numeric value of
0.0f represents false.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for computing <code>this</code> &lt; <code>that</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> lessThan <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#&lt;=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;=(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="&lt;=(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$eq" class="name">&lt;=</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;=(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>x lessThanEqual that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>x lessThanEqual that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for &lt;= operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>x lessThanEqual that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#&lt;=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;=(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="&lt;=(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$eq" class="name">&lt;=</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;=(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compare two fields using the &quot;less than equal&quot; operator; a numeric value
of 1.0f represents true (first operand &lt;= second operand) and a numeric
value of 0.0f represents false.</p><div class="fullcomment"><div class="comment cmt"><p>Compare two fields using the &quot;less than equal&quot; operator; a numeric value
of 1.0f represents true (first operand &lt;= second operand) and a numeric
value of 0.0f represents false.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for computing <code>this</code> &lt;- <code>that</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> lessThanOrEquel <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor#&lt;==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;==(that:cogx.compiler.parser.syntaxtree.Field):Unit"></a>
      <a id="&lt;==(Field):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$eq$eq" class="name">&lt;==</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&lt;==(that:cogx.compiler.parser.syntaxtree.Field):Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Feedback to inputs is not allowed.</p><div class="fullcomment"><div class="comment cmt"><p>Feedback to inputs is not allowed.</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Field whose value will become <code>this</code> field's value on the next clock tick.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor">UnpipelinedVectorSensor</a> → <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@==(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#===" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="===(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="===(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq$eq" class="name">===</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@===(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>x identicallyEquals that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>x identicallyEquals that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for === operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>x identicallyEquals that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#===" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="===(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="===(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq$eq" class="name">===</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@===(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compare two fields using the &quot;identically equal&quot; operator; a numeric value
of 1.0f represents true (first operand == second operand) and a numeric
value of 0.0f represents false.</p><div class="fullcomment"><div class="comment cmt"><p>Compare two fields using the &quot;identically equal&quot; operator; a numeric value
of 1.0f represents true (first operand == second operand) and a numeric
value of 0.0f represents false.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for computing <code>this</code> === <code>that</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> identicallyEqualTo <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&gt;(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="&gt;(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $greater" class="name">&gt;</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&gt;(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>x greaterThan that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>x greaterThan that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for &gt; operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>x greaterThan that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&gt;(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="&gt;(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $greater" class="name">&gt;</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&gt;(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compare two fields using the &quot;greater than&quot; operator; a numeric
value of 1.0f represents true (first operand &gt; second operand) and a
numeric value of 0.0f represents false.</p><div class="fullcomment"><div class="comment cmt"><p>Compare two fields using the &quot;greater than&quot; operator; a numeric
value of 1.0f represents true (first operand &gt; second operand) and a
numeric value of 0.0f represents false.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for computing <code>this</code> &gt; <code>that</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> greaterThan <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#&gt;=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&gt;=(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="&gt;=(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $greater$eq" class="name">&gt;=</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&gt;=(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>x greaterThanEqual that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>x greaterThanEqual that</code> where
1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for &gt;= operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>x greaterThanEqual that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#&gt;=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&gt;=(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="&gt;=(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $greater$eq" class="name">&gt;=</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@&gt;=(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compare two fields using the &quot;greater than or equal&quot; operator; a numeric
value of 1.0f represents true (first operand &gt;= second operand) and a
numeric value of 0.0f represents false.</p><div class="fullcomment"><div class="comment cmt"><p>Compare two fields using the &quot;greater than or equal&quot; operator; a numeric
value of 1.0f represents true (first operand &gt;= second operand) and a
numeric value of 0.0f represents false.</p><p>This operator follows the <i>algebraic binary operator rules</i> for input
type compatibility, implicit type conversions, and output result type.
See the class description for these rules.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for computing <code>this</code> &gt;= <code>that</code>.</p></dd><dt>returns</dt><dd class="cmt"><p><code>this</code> greaterThanOrEqual <code>that</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#^" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="^(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="^(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $up" class="name">^</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@^(that:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the outer product of Scalarfields <code>this</code> and <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the outer product of Scalarfields <code>this</code> and <code>that</code>.  The
output field has a field shape that is the concatenation of the two
input field shapes, and must be at most 3-dimensional.  Each output
element is calculated as in:</p><p>out(in1Indices, in2Indices) = in1(in1Indices) * in2(in2Indices)</p><p>This operation is implemented by a CPU kernel, so will be slow for big inputs.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>Operand for computing <code>this</code> <code>^<code> </code>that<code>.</code></code></p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to the outer product of <code>this</code> and <code>that</code>,</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#abs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="abs:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="abs:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">abs</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@abs:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the absolute value of every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the absolute value of every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       absoluteValue(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#acos" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acos:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="acos:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acos</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@acos:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the arccosine of every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the arccosine of every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       acos(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#apply" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="apply(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="f2">f2: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@apply(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce the dimensionality of a field by 1 by &quot;slicing&quot; along one index
of the first dimension.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce the dimensionality of a field by 1 by &quot;slicing&quot; along one index
of the first dimension.</p><p>For example, consider this input (3 rows x 4 columns) field:</p><pre><span class="num">0</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>
<span class="num">4</span>  <span class="num">5</span>  <span class="num">6</span>  <span class="num">7</span>
<span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">1</span></pre><p>The first dimension is rows, so a &quot;slice index&quot; of 0 would return
the first row:</p><pre><span class="num">0</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span></pre><p>A slice index of 1 would return the second row:</p><pre><span class="num">4</span>  <span class="num">5</span>  <span class="num">6</span>  <span class="num">7</span></pre><p>And a slice index of 2 would return the third row:</p><pre><span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">1</span></pre></div><dl class="paramcmts block"><dt class="param">f2</dt><dd class="cmt"><p>A 0D scalar field supplying the index of the first dimension
          along which we will slice out a lower-dimensional field.</p></dd><dt>returns</dt><dd class="cmt"><p>A sliced field, of dimension one less than the input field
      dimension.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#apply" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply(index:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="apply(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="index">index: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@apply(index:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce the dimensionality of a field by 1 by &quot;slicing&quot; along one index
of the first dimension.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce the dimensionality of a field by 1 by &quot;slicing&quot; along one index
of the first dimension.</p><p>For example, consider this input (3 rows x 4 columns) field:</p><pre><span class="num">0</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>
<span class="num">4</span>  <span class="num">5</span>  <span class="num">6</span>  <span class="num">7</span>
<span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">1</span></pre><p>The first dimension is rows, so a &quot;slice index&quot; of 0 would return
the first row:</p><pre><span class="num">0</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span></pre><p>A slice index of 1 would return the second row:</p><pre><span class="num">4</span>  <span class="num">5</span>  <span class="num">6</span>  <span class="num">7</span></pre><p>And a slice index of 2 would return the third row:</p><pre><span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">1</span></pre></div><dl class="paramcmts block"><dt class="param">index</dt><dd class="cmt"><p>The index of the first dimension along which we will slice
      out a lower-dimensional field.</p></dd><dt>returns</dt><dd class="cmt"><p>A sliced field, of dimension one less than the input field
      dimension.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#apply" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply(ranges:Range*):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="apply(Range*):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="ranges">ranges: <span class="extype" name="scala.Range">Range</span>*</span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@apply(ranges:Range*):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extract a contiguous subfield from a field, maintaining its
dimensionality.</p><div class="fullcomment"><div class="comment cmt"><p>Extract a contiguous subfield from a field, maintaining its
dimensionality.</p><p>Each dimension of a field is indexed starting a zero. The user supplies
a range of indices, one for each dimension, that specifies the continguous
range of indices that should be extracted into the subfield.</p><p>For example, consider this input field:</p><pre><span class="num">0</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>
<span class="num">4</span>  <span class="num">5</span>  <span class="num">6</span>  <span class="num">7</span>
<span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">1</span></pre><p>This has 3 rows (first dimension) and 4 columns (second dimension) so
its shape is 3 x 4. Specify row range (1 to 2) and column range (1 to 3)
would extract the following subfield:</p><pre><span class="num">5</span>  <span class="num">6</span>  <span class="num">7</span>
<span class="num">9</span>  <span class="num">0</span>  <span class="num">1</span></pre><p>If the use of this subfield does not shift the origin, then use a trim instead
which might be more efficient due to kernel merging.
</p></div><dl class="paramcmts block"><dt class="param">ranges</dt><dd class="cmt"><p>For each dimension, a range of indices specifying where
       to extract the subfield.</p></dd><dt>returns</dt><dd class="cmt"><p>Subfield of input as specified by the <code>range</code> parameters.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@asInstanceOf[T0]:T0" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#asin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asin:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="asin:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asin</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@asin:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the arcsine of every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the arcsine of every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       asin(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#atan2" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="atan2(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="atan2(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">atan2</span><span class="params">(<span name="f2">f2: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@atan2(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute atan2 of two identically shaped scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Compute atan2 of two identically shaped scalar fields.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A scalar field that's the atan2 of the two input fields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#backProjectFrame" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="backProjectFrame(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="backProjectFrame(Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy,Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">backProjectFrame</span><span class="params">(<span name="filter">filter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../../../package.html">NoSamplingConvolution</a></span></span></span>, <span name="batchSize">batchSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@backProjectFrame(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convolve a vector field with a vector-field filter frame.</p><div class="fullcomment"><div class="comment cmt"><p>Convolve a vector field with a vector-field filter frame.
</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for convolution; must be square and with
       odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling convolution along borders,
       implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       convolution, also helps to determine the size of output field.</p></dd><dt class="param">batchSize</dt><dd class="cmt"><p>The number of logical (possibly multi-plane) images present in the input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field convolved with <code>filter</code> using the supplied border
       and sampling policies.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#backwardDivergence" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="backwardDivergence:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="backwardDivergence:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">backwardDivergence</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@backwardDivergence:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the backward divergence of a 2D vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the backward divergence of a 2D vector field.</p><p>This is the adjoint operator of forwardGradient.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A scalar field representing the backward divergence of an
       input vector field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#backwardGradient" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="backwardGradient:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="backwardGradient:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">backwardGradient</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@backwardGradient:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the backward gradient of a 2D scalar or vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the backward gradient of a 2D scalar or vector field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>For a scalar field input, a vector field representing the
        forward gradient of the input; for a vector input field, an
        order 4 tensor field representing the forward gradient of the
        input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#bilateralFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bilateralFilter(spatialFilter:cogx.cogmath.algebra.real.Matrix,rangeSigma:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="bilateralFilter(cogmath.algebra.real.Matrix,Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bilateralFilter</span><span class="params">(<span name="spatialFilter">spatialFilter: <a href="../../../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>, <span name="rangeSigma">rangeSigma: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@bilateralFilter(spatialFilter:cogx.cogmath.algebra.real.Matrix,rangeSigma:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform bilateral filtering using <code>spatialFilter</code> for spatial filtering
(typically this will be a truncated Gaussian) and a Gaussian with
width <code>rangeSigma</code> for range filtering.</p><div class="fullcomment"><div class="comment cmt"><p>Perform bilateral filtering using <code>spatialFilter</code> for spatial filtering
(typically this will be a truncated Gaussian) and a Gaussian with
width <code>rangeSigma</code> for range filtering.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#blockReduceMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockReduceMax(factor:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="blockReduceMax(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockReduceMax</span><span class="params">(<span name="factor">factor: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@blockReduceMax(factor:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
taking the max() of the first <code>factor</code> input vector elements to form the
first output vector element, and so forth.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
taking the max() of the first <code>factor</code> input vector elements to form the
first output vector element, and so forth.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A vector field with each element equal to the max() of <code>factor</code>
        components of the corresponding vector in the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#blockReduceMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockReduceMin(factor:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="blockReduceMin(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockReduceMin</span><span class="params">(<span name="factor">factor: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@blockReduceMin(factor:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
taking the min() of the first <code>factor</code> input vector elements to form the
first output vector element, and so forth.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
taking the min() of the first <code>factor</code> input vector elements to form the
first output vector element, and so forth.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A vector field with each element equal to the min() of <code>factor</code>
        components of the corresponding vector in the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#blockReduceSum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockReduceSum(factor:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="blockReduceSum(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockReduceSum</span><span class="params">(<span name="factor">factor: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@blockReduceSum(factor:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
summing the first <code>factor</code> input vector elements to form the first output
vector element, and so forth.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a shorter (by factor <code>factor</code>) vector field by
summing the first <code>factor</code> input vector elements to form the first output
vector element, and so forth.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A vector field with each element equal to the sum of <code>factor</code>
        components of the corresponding vector in the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#centralGradient" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="centralGradient:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="centralGradient:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">centralGradient</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@centralGradient:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the central gradient of a scalar of vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the central gradient of a scalar of vector field.</p><p>The central gradient at the point (x, y) is computed using the values at
(x - 1, y), (x, y - 1), (x, y + 1), and (x + 1, y + 1)
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>For a scalar field input, returns a vectorField representing the
       central gradient of the input. For a vector field input, returns
       an order-4 tensor field representing the central gradient of the
       input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@clone():Object" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="cogx.platform.types.FieldParameters#columns" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="columns:Int"></a>
      <a id="columns:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">columns</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@columns:Int" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">&quot;Columns&quot; in the field.</p><div class="fullcomment"><div class="comment cmt"><p>&quot;Columns&quot; in the field. See class description for meaning of columns.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>FieldParameters</dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#complexToCogComplex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="complexToCogComplex(c:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.CogComplex"></a>
      <a id="complexToCogComplex(cogmath.algebra.complex.Complex):CogComplex"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">complexToCogComplex</span><span class="params">(<span name="c">c: <a href="../../../cogmath/algebra/complex/Complex.html" class="extype" name="cogx.cogmath.algebra.complex.Complex">cogmath.algebra.complex.Complex</a></span>)</span><span class="result">: <span class="extype" name="cogx.compiler.parser.syntaxtree.CogComplex">CogComplex</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@complexToCogComplex(c:cogx.cogmath.algebra.complex.Complex):cogx.compiler.parser.syntaxtree.CogComplex" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Complex to a CogComplex which allows for fields
to be combined with floating point numbers in a simple way.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Complex to a CogComplex which allows for fields
to be combined with floating point numbers in a simple way.
This makes it possible to express commutative operations with a common
syntax.</p><p>For example</p><pre>Field + Complex</pre><p>and</p><pre>Complex + Field</pre><p>are both legal and compilable with this implicit conversion.
</p></div><dl class="paramcmts block"><dt class="param">c</dt><dd class="cmt"><p>The Complex to be converted to a CogComplex</p></dd><dt>returns</dt><dd class="cmt"><p>The CogComplex created from <code>c</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#complexVectorTo0DComplexVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="complexVectorTo0DComplexVectorField(v:cogx.cogmath.algebra.complex.ComplexVector):cogx.compiler.parser.syntaxtree.ComplexVectorField"></a>
      <a id="complexVectorTo0DComplexVectorField(cogmath.algebra.complex.ComplexVector):ComplexVectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">complexVectorTo0DComplexVectorField</span><span class="params">(<span name="v">v: <a href="../../../cogmath/algebra/complex/ComplexVector.html" class="extype" name="cogx.cogmath.algebra.complex.ComplexVector">cogmath.algebra.complex.ComplexVector</a></span>)</span><span class="result">: <a href="ComplexVectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexVectorField">ComplexVectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@complexVectorTo0DComplexVectorField(v:cogx.cogmath.algebra.complex.ComplexVector):cogx.compiler.parser.syntaxtree.ComplexVectorField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a ComplexVector to a 0D constant ComplexVectorField
which allows for fields to be combined with ComplexVectors in a simple way.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a ComplexVector to a 0D constant ComplexVectorField
which allows for fields to be combined with ComplexVectors in a simple way.
This makes it possible to express commutative operations with a common
syntax.</p><p>For example</p><pre>Field + ComplexVector</pre><p>and</p><pre>ComplexVector + Field</pre><p>are both legal and compilable with this implicit conversion.
</p></div><dl class="paramcmts block"><dt class="param">v</dt><dd class="cmt"><p>The complex vector to be converted to a 0D complex vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>A 0D complex vector field initialized to <code>v</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#conditionNumber" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conditionNumber:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="conditionNumber:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">conditionNumber</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@conditionNumber:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Given a matrix field, compute the condition number for each matrix in
that field.</p><div class="fullcomment"><div class="comment cmt"><p>Given a matrix field, compute the condition number for each matrix in
that field. This is currently limited to fields containing 2 x 2 matrices.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Scalar field holding the condition numbers for the corresponding
        matrices in the input matrix field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#conjugate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="conjugate:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="conjugate:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">conjugate</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@conjugate:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the complex conjugate of each element in a complex field</p><div class="fullcomment"><div class="comment cmt"><p>Take the complex conjugate of each element in a complex field</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#convolve" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="convolve(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="convolve(Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">convolve</span><span class="params">(<span name="filter">filter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../../../package.html">NoSamplingConvolution</a></span></span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@convolve(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convolve a scalar/vector/matrix field with a filter.</p><div class="fullcomment"><div class="comment cmt"><p>Convolve a scalar/vector/matrix field with a filter.
</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for convolution; must be square and with
       odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling convolution along borders,
       implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       convolution, also helps to determine the size of output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field convolved with <code>filter</code> using the supplied border
       and sampling policies.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#convolveFilterAdjoint" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="convolveFilterAdjoint(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="convolveFilterAdjoint(Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy,Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">convolveFilterAdjoint</span><span class="params">(<span name="filter">filter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../../../package.html">NoSamplingConvolution</a></span></span></span>, <span name="batchSize">batchSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@convolveFilterAdjoint(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convolve a vector field with a vector-field with &quot;filter adjoint&quot; plane mixing.</p><div class="fullcomment"><div class="comment cmt"><p>Convolve a vector field with a vector-field with &quot;filter adjoint&quot; plane mixing.
</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for convolution; must be square and with
       odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling convolution along borders,
       implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       convolution, also helps to determine the size of output field.</p></dd><dt class="param">batchSize</dt><dd class="cmt"><p>The number of logical (possibly multi-plane) images present in the input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field convolved with <code>filter</code> using the supplied border
       and sampling policies.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#convolveSeparable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="convolveSeparable(rowFilter:cogx.compiler.parser.syntaxtree.Field,columnFilter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="convolveSeparable(Field,Field,platform.types.BorderPolicy):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">convolveSeparable</span><span class="params">(<span name="rowFilter">rowFilter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="columnFilter">columnFilter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@convolveSeparable(rowFilter:cogx.compiler.parser.syntaxtree.Field,columnFilter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convolve a scalar/vector/matrix field with a row filter and a
column filter (separable convolution).</p><div class="fullcomment"><div class="comment cmt"><p>Convolve a scalar/vector/matrix field with a row filter and a
column filter (separable convolution).
</p></div><dl class="paramcmts block"><dt class="param">rowFilter</dt><dd class="cmt"><p>The filter to use for convolving the rows
       with odd size in each dimension.</p></dd><dt class="param">columnFilter</dt><dd class="cmt"><p>The filter to use for convolving the columns
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling convolution along
       borders, implicitly helps to determine size of output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field convolved with filters using the supplied
       border policy.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#cos" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cos:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="cos:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cos</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@cos:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the cosine of every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the cosine of every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       cos(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#cosh" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cosh:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="cosh:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cosh</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@cosh:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the hyperbolic cosine of every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Take the hyperbolic cosine of every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       cosh(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#crossCorrelate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="crossCorrelate(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="crossCorrelate(Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">crossCorrelate</span><span class="params">(<span name="filter">filter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../../../package.html">NoSamplingConvolution</a></span></span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@crossCorrelate(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cross-correlate a scalar/vector/matrix field with a filter.</p><div class="fullcomment"><div class="comment cmt"><p>Cross-correlate a scalar/vector/matrix field with a filter.
</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for cross-correlation; must be square and
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling cross-correlation along
       borders, implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       crossCorrelation, also helps to determine the size of output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field cross-correlated with <code>filter</code> using the supplied
       border and sampling policies.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#crossCorrelateFilterAdjoint" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="crossCorrelateFilterAdjoint(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="crossCorrelateFilterAdjoint(Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy,Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">crossCorrelateFilterAdjoint</span><span class="params">(<span name="filter">filter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../../../package.html">NoSamplingConvolution</a></span></span></span>, <span name="batchSize">batchSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@crossCorrelateFilterAdjoint(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cross-correlate a vector field with a vector-field with &quot;filter adjoint&quot; plane mixing.</p><div class="fullcomment"><div class="comment cmt"><p>Cross-correlate a vector field with a vector-field with &quot;filter adjoint&quot; plane mixing.
</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for cross-correlation; must be square and
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling cross-correlation along
       borders, implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       crossCorrelation, also helps to determine the size of output field.</p></dd><dt class="param">batchSize</dt><dd class="cmt"><p>The number of logical (possibly multi-plane) images present in the input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field cross-correlated with <code>filter</code> using the supplied
       border and sampling policies.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#crossCorrelateSeparable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="crossCorrelateSeparable(rowFilter:cogx.compiler.parser.syntaxtree.Field,columnFilter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="crossCorrelateSeparable(Field,Field,platform.types.BorderPolicy):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">crossCorrelateSeparable</span><span class="params">(<span name="rowFilter">rowFilter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="columnFilter">columnFilter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@crossCorrelateSeparable(rowFilter:cogx.compiler.parser.syntaxtree.Field,columnFilter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cross-correlate a scalar/vector/matrix field with a row filter and a
column filter (separable convolution).</p><div class="fullcomment"><div class="comment cmt"><p>Cross-correlate a scalar/vector/matrix field with a row filter and a
column filter (separable convolution).
</p></div><dl class="paramcmts block"><dt class="param">rowFilter</dt><dd class="cmt"><p>The filter to use for cross-correlating the rows
       with odd size in each dimension.</p></dd><dt class="param">columnFilter</dt><dd class="cmt"><p>The filter to use for cross-correlating the columns
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling cross-correlation along
       borders, implicitly helps to determine size of output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field cross-correlated with filters using the supplied
       border policy.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#crossDot" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="crossDot(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="crossDot(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">crossDot</span><span class="params">(<span name="f2">f2: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@crossDot(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Multiply a 2D matrix field, <code>this</code>, by a 2D scalar field, <code>f2</code>, to
produce a 2D scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Multiply a 2D matrix field, <code>this</code>, by a 2D scalar field, <code>f2</code>, to
produce a 2D scalar field.</p><p>The scalar field <code>f2</code> must have the same shape as the matrices in <code>this</code>.
This operator is basically pretending that the <code>f2</code> scalar field is
really a matrix and simply dotting that matrix with every matrix in the
matrix field <code>this</code>, producing a scalar in the corresponding position
of the result scalar field.
</p></div><dl class="paramcmts block"><dt class="param">f2</dt><dd class="cmt"><p>Scalar field to multiply with <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>&quot;cross dot&quot; product of <code>this</code> and <code>f2</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#dct" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dct:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dct:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dct</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@dct:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the DCT (discrete cosine transform) of a 2D field, producing a
field with the same shape as the input.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the DCT (discrete cosine transform) of a 2D field, producing a
field with the same shape as the input.</p><p>The following sequence will return the original input, within the bounds
of computational error:</p><pre><span class="kw">val</span> field
<span class="kw">val</span> transformed = field.dct
<span class="kw">val</span> restored = transformed.dctInverse
<span class="cmt">// restored is approximately equal to field</span></pre><p>For a somewhat faster version, see dctTransposed.</p><p>The DCT has several requirements:</p><p>The number of rows and columns must each be a power of 2.</p><p>Rows and columns are restricted to the range [256, 2048]
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The DCT of the input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#dctInverse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dctInverse:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dctInverse:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dctInverse</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@dctInverse:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the inverse DCT (discrete cosine transform) of a 2D field, producing
a field with the same shape as the input.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the inverse DCT (discrete cosine transform) of a 2D field, producing
a field with the same shape as the input.</p><p>The following sequence will return the original input, within the bounds
of computational error:</p><pre><span class="kw">val</span> field
<span class="kw">val</span> transformed = field.dct
<span class="kw">val</span> restored = transformed.dctInverse
<span class="cmt">// restored is approximately equal to field</span></pre><p>For a somewhat faster version, see dctInverseTransposed.</p><p>The DCT has several requirements:</p><p>The number of rows and columns must each be a power of 2.</p><p>Rows and columns are restricted to the range [256, 2048]
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The DCT of the input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#dctInverseTransposed" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dctInverseTransposed:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dctInverseTransposed:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dctInverseTransposed</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@dctInverseTransposed:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the inverse DCT (discrete cosine transform) of a 2D field, producing
a field with the same shape as the input.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the inverse DCT (discrete cosine transform) of a 2D field, producing
a field with the same shape as the input.</p><p>The following sequence will return the original input, within the bounds
of computational error:</p><pre><span class="kw">val</span> field
<span class="kw">val</span> transformed = field.dctTransposed
<span class="kw">val</span> restored = transformed.dctInverseTransposed
<span class="cmt">// restored is approximately equal to field</span></pre><p>This is a somewhat faster version of dctInverse where the transpose is not
important to (or can be compensated within) an application.</p><p>The DCT has several requirements:</p><p>The number of rows and columns must each be a power of 2.</p><p>Rows and columns are restricted to the range [256, 2048]
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The DCT of the input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#dctTransposed" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dctTransposed:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dctTransposed:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dctTransposed</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@dctTransposed:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the DCT (discrete cosine transform) of a 2D field and transposes it,
producing a field with the same shape as the input transposed.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the DCT (discrete cosine transform) of a 2D field and transposes it,
producing a field with the same shape as the input transposed.</p><p>The following sequence will return the original input, within the bounds
of computational error:</p><pre><span class="kw">val</span> field
<span class="kw">val</span> transformed = field.dctTransposed
<span class="kw">val</span> restored = transformed.dctInverseTransposed
<span class="cmt">// restored is approximately equal to field</span></pre><p>This is a somewhat faster version of dct where the transpose is not
important to (or can be compensated within) an application.</p><p>The DCT has several requirements:</p><p>The number of rows and columns must each be a power of 2.</p><p>Rows and columns are restricted to the range [256, 2048]
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The DCT of the input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#determinant" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="determinant:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="determinant:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">determinant</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@determinant:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the determinant of every matrix in a matrix field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the determinant of every matrix in a matrix field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Scalar field holding the determinants for the corresponding
        matrices in the input matrix field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.platform.types.FieldParameters#dimensions" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dimensions:Int"></a>
      <a id="dimensions:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">dimensions</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@dimensions:Int" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Dimensions of the field.</p><div class="fullcomment"><div class="comment cmt"><p>Dimensions of the field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>FieldParameters</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#domainFilterColumns" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="domainFilterColumns(domainTransform:cogx.compiler.parser.syntaxtree.ScalarField,boxFilterRadius:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="domainFilterColumns(ScalarField,Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">domainFilterColumns</span><span class="params">(<span name="domainTransform">domainTransform: <a href="ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">ScalarField</a></span>, <span name="boxFilterRadius">boxFilterRadius: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@domainFilterColumns(domainTransform:cogx.compiler.parser.syntaxtree.ScalarField,boxFilterRadius:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform a &quot;domain filter&quot; on the columns of a color field as a step in
edge-aware normalized convolution.</p><div class="fullcomment"><div class="comment cmt"><p>Perform a &quot;domain filter&quot; on the columns of a color field as a step in
edge-aware normalized convolution. This &quot;correlates&quot; an adaptive box
filter with each pixel in the columns of the color field, guided by
<code>domainTransform</code>.</p><p>This operation works only on color fields and is an optimization. The
following code sequences, A and B, are functionally identical:</p><pre><span class="cmt">// Prepare for filtering</span>
<span class="kw">val</span> rowTransform = colorImage.domainTransformRows(...)
<span class="kw">val</span> colTransform = colorImage.transpose.domainTransformRows(...)

<span class="cmt">// Sequence A (slower)</span>
<span class="kw">var</span> smooth = colorImage
smooth = smooth.domainFilterRows(rowTransform, ...)
smooth = smooth.transpose.domainFilterRows(colTransform, ...).transpose

<span class="cmt">// Sequence B, using this operation (faster, no transposes)</span>
<span class="kw">var</span> smooth = colorImage
smooth = smooth.domainFilterRows(rowTransform, ...)
smooth = smooth.domainFilterColumns(colTransform, ...)</pre><p>For details, see the paper &quot;Domain transform
for edge-aware image and video processing,&quot; Gastal and Oliveira, 2011.
Normally this is not useful for end-users, but you're welcome to try it
if you would like to write your own edge-aware filters.
</p></div><dl class="paramcmts block"><dt class="param">domainTransform</dt><dd class="cmt"><p>The cumulative domain transform for the image.</p></dd><dt class="param">boxFilterRadius</dt><dd class="cmt"><p>Radius of box filter.</p></dd><dt>returns</dt><dd class="cmt"><p>The domain transform of the columns (equation 11) in the
        Gastal paper as a scalar field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#domainFilterRows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="domainFilterRows(domainTransform:cogx.compiler.parser.syntaxtree.Field,boxFilterRadius:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="domainFilterRows(Field,Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">domainFilterRows</span><span class="params">(<span name="domainTransform">domainTransform: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="boxFilterRadius">boxFilterRadius: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@domainFilterRows(domainTransform:cogx.compiler.parser.syntaxtree.Field,boxFilterRadius:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform a &quot;domain filter&quot; on the rows of a tensor or color field as a step
in edge-aware normalized convolution.</p><div class="fullcomment"><div class="comment cmt"><p>Perform a &quot;domain filter&quot; on the rows of a tensor or color field as a step
in edge-aware normalized convolution. This &quot;correlates&quot; an adaptive box
filter with each pixel in the rows of the color field, guided by
<code>domainTransform</code>.</p><p>For details, see the paper &quot;Domain transform
for edge-aware image and video processing,&quot; Gastal and Oliveira, 2011.
Normally this is not useful for end-users, but you're welcome to try it
if you would like to write your own edge-aware filters.
</p></div><dl class="paramcmts block"><dt class="param">domainTransform</dt><dd class="cmt"><p>The cumulative domain transform for the image.</p></dd><dt class="param">boxFilterRadius</dt><dd class="cmt"><p>Radius of box filter.</p></dd><dt>returns</dt><dd class="cmt"><p>The domain transform of the rows (equation 11) in the
        Gastal paper as a scalar field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#domainTransformRows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="domainTransformRows(spaceSigma:Float,rangeSigma:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="domainTransformRows(Float,Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">domainTransformRows</span><span class="params">(<span name="spaceSigma">spaceSigma: <span class="extype" name="scala.Float">Float</span></span>, <span name="rangeSigma">rangeSigma: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@domainTransformRows(spaceSigma:Float,rangeSigma:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform a &quot;domain transform&quot; on the rows of a color field or tensor field
as a step in edge-aware normalized convolution.</p><div class="fullcomment"><div class="comment cmt"><p>Perform a &quot;domain transform&quot; on the rows of a color field or tensor field
as a step in edge-aware normalized convolution.</p><p>For details, see the paper &quot;Domain transform
for edge-aware image and video processing,&quot; Gastal and Oliveira, 2011.
Normally this is not useful for end-users, but you're welcome to try it
if you would like to write your own edge-aware filters.
</p></div><dl class="paramcmts block"><dt class="param">spaceSigma</dt><dd class="cmt"><p>Width of filter in space.</p></dd><dt class="param">rangeSigma</dt><dd class="cmt"><p>Width of filter in range.</p></dd><dt>returns</dt><dd class="cmt"><p>The domain transform of the rows (equation 11) in the
        Gastal paper as a scalar field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#dot" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dot(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="dot(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dot</span><span class="params">(<span name="f2">f2: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@dot(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Takes the inner product of two identically shaped tensor fields to
create a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the inner product of two identically shaped tensor fields to
create a scalar field.</p><p>The tensors in both fields must have the same shape. Dotting two tensors
involves multiplying corresponding elements in the two tensors and
summing the products.
</p></div><dl class="paramcmts block"><dt class="param">f2</dt><dd class="cmt"><p>Other field to &quot;dot&quot; with <code>this</code> field.</p></dd><dt>returns</dt><dd class="cmt"><p>Scalar field where each scalar element is computed from the dot
      product of the tensors in the corresponding location of the two
      input tensor fields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#downsample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="downsample(factor:Int,phase:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="downsample(Int,Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">downsample</span><span class="params">(<span name="factor">factor: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">2</span></span>, <span name="phase">phase: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@downsample(factor:Int,phase:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Downsample a field by taking every nth element.</p><div class="fullcomment"><div class="comment cmt"><p>Downsample a field by taking every nth element.</p><p>Example: for input field {1,2,3,4}</p><p>    input.downsample(2) yields {1,3}</p><p>    input.downsample(2,1) yields {2,4}
</p></div><dl class="paramcmts block"><dt class="param">factor</dt><dd class="cmt"><p>The sampling factor, defaults to 2.</p></dd><dt class="param">phase</dt><dd class="cmt"><p>The offset within the downsampled region from which to
       take data, defaults to an offset of 0.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@eq(x$1:AnyRef):Boolean" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@equals(x$1:Any):Boolean" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#exp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="exp:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="exp:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exp</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@exp:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the exponential function to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the exponential function to every numeric element in <code>this</code>. This
works for complex and real fields.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       exp(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#expand" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expand(borderPolicy:cogx.platform.types.BorderPolicy,sizes:Int*):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="expand(platform.types.BorderPolicy,Int*):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expand</span><span class="params">(<span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="sizes">sizes: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@expand(borderPolicy:cogx.platform.types.BorderPolicy,sizes:Int*):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Expand an N-dimensional field by padding it with values per the border
policy, maintaining the origin.</p><div class="fullcomment"><div class="comment cmt"><p>Expand an N-dimensional field by padding it with values per the border
policy, maintaining the origin. The supported border policies are
BorderZero, BorderClamp and BorderCyclic.</p><p>See expand(borderPolicy, shape) for a description of the border policies.
</p></div><dl class="paramcmts block"><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for producing border values.</p></dd><dt class="param">sizes</dt><dd class="cmt"><p>The integer dimensions of the expanded output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Expanded field with new elements filled in from the nearest input
      edge per <code>borderPolicy</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#expand" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expand(borderPolicy:cogx.platform.types.BorderPolicy,shape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="expand(platform.types.BorderPolicy,cogmath.geometry.Shape):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expand</span><span class="params">(<span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="shape">shape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@expand(borderPolicy:cogx.platform.types.BorderPolicy,shape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Expand an N-dimensional field by padding it with values per the border
policy, maintaining the origin.</p><div class="fullcomment"><div class="comment cmt"><p>Expand an N-dimensional field by padding it with values per the border
policy, maintaining the origin. The supported border policies are
BorderZero, BorderClamp and BorderCyclic.</p><p>With the BorderZero policy, the border values are all 0.</p><p>Border Zero Example. A 3 x 4 input field:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span></pre><p>If we expand this to 7 x 8, we fill the new elements with zeroes:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span></pre><p>With the BorderClamp policy, the border is extended outwards into the expanded
output field, wrapping around as though the output field were a torus.
This is useful when doing convolution with the FFT and one wishes to
minimize border effects by &quot;border clamping&quot;.</p><p>BorderClamp Example. A 3 x 4 input field:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span></pre><p>If we expand this to 7 x 8, we extend the borders, wrapping around as
though the output field were a torus:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">4</span>  <span class="num">4</span>  <span class="num">1</span>  <span class="num">1</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">6</span>  <span class="num">6</span>  <span class="num">5</span>  <span class="num">5</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">7</span>  <span class="num">7</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>
<span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span>  <span class="num">0</span></pre><p>With the BorderCyclic policy, the border values emulate a cyclic
&quot;wrap-around&quot; in the original field, as though the input field were a torus.
This is useful when doing cyclic convolution with the FFT and one wishes
expand the field to make it a power of 2 (necessary for the FFT) while
still preserving cyclic convolution</p><p>BorderCyclic Example. A 3 x 4 input field:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span></pre><p>If we expand this to 7 x 8, we extend the borders, wrapping around as
though the input field were a torus:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>
<span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>  <span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>  <span class="num">4</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>  <span class="num">5</span> -<span class="num">1</span> -<span class="num">1</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span>  <span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span>  <span class="num">0</span></pre></div><dl class="paramcmts block"><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for producing border values.</p></dd><dt class="param">shape</dt><dd class="cmt"><p>The shape of the expanded output field.</p></dd><dt>returns</dt><dd class="cmt"><p>Expanded field with new elements filled in from the nearest input
      edge per <code>borderPolicy</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fft" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fft:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fft:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fft</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fft:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the FFT of a complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the FFT of a complex field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fftColumns" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftColumns:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftColumns:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftColumns</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fftColumns:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the FFT of the columns only in a 2D complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the FFT of the columns only in a 2D complex field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fftInverse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftInverse:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftInverse:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftInverse</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fftInverse:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the inverse FFT of a complex field (includes scaling).</p><div class="fullcomment"><div class="comment cmt"><p>Compute the inverse FFT of a complex field (includes scaling).</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fftInverseColumns" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftInverseColumns:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftInverseColumns:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftInverseColumns</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fftInverseColumns:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the inverseFFT of the columns only in a 2D complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the inverseFFT of the columns only in a 2D complex field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fftInverseRows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftInverseRows:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftInverseRows:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftInverseRows</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fftInverseRows:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the inverse FFT of the rows only in a 2D complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the inverse FFT of the rows only in a 2D complex field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fftRows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fftRows:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fftRows:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fftRows</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fftRows:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the FFT of the rows only in a 2D complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the FFT of the rows only in a 2D complex field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldArrayToMatrixFieldArray" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldArrayToMatrixFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.MatrixField]"></a>
      <a id="fieldArrayToMatrixFieldArray(Array[Field]):Array[MatrixField]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldArrayToMatrixFieldArray</span><span class="params">(<span name="a">a: <span class="extype" name="scala.Array">Array</span>[<a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<a href="MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">MatrixField</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldArrayToMatrixFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.MatrixField]" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of an array of Fields to an array of ScalarFields.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of an array of Fields to an array of ScalarFields.
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>An array of Fields.</p></dd><dt>returns</dt><dd class="cmt"><p>An array of MatrixFields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldArrayToScalarFieldArray" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldArrayToScalarFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.ScalarField]"></a>
      <a id="fieldArrayToScalarFieldArray(Array[Field]):Array[ScalarField]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldArrayToScalarFieldArray</span><span class="params">(<span name="a">a: <span class="extype" name="scala.Array">Array</span>[<a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<a href="ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">ScalarField</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldArrayToScalarFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.ScalarField]" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of an array of Fields to an array of ScalarFields.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of an array of Fields to an array of ScalarFields.
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>An array of Fields.</p></dd><dt>returns</dt><dd class="cmt"><p>An array of ScalarFields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldArrayToVectorFieldArray" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldArrayToVectorFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.VectorField]"></a>
      <a id="fieldArrayToVectorFieldArray(Array[Field]):Array[VectorField]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldArrayToVectorFieldArray</span><span class="params">(<span name="a">a: <span class="extype" name="scala.Array">Array</span>[<a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<a href="VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">VectorField</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldArrayToVectorFieldArray(a:Array[cogx.compiler.parser.syntaxtree.Field]):Array[cogx.compiler.parser.syntaxtree.VectorField]" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of an array of Fields to an array of ScalarFields.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of an array of Fields to an array of ScalarFields.
</p></div><dl class="paramcmts block"><dt class="param">a</dt><dd class="cmt"><p>An array of Fields.</p></dd><dt>returns</dt><dd class="cmt"><p>An array of VectorFields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fieldReduceMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldReduceMax:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fieldReduceMax:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldReduceMax</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldReduceMax:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a scalar field to a 0D scalar containing a single element which
is the maximum element in the input field.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a scalar field to a 0D scalar containing a single element which
is the maximum element in the input field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>0D scalar field holding the max value in input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fieldReduceMedian" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldReduceMedian:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fieldReduceMedian:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldReduceMedian</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldReduceMedian:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Find the median value in a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Find the median value in a scalar field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>0D scalar field holding the median value of the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fieldReduceMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldReduceMin:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fieldReduceMin:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldReduceMin</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldReduceMin:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a scalar field to a 0D scalar containing a single element which
is the minimum element in the input field.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a scalar field to a 0D scalar containing a single element which
is the minimum element in the input field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>0D scalar field holding the min value in input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fieldReduceSum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldReduceSum:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="fieldReduceSum:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldReduceSum</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldReduceSum:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a scalar field to a 0D scalar containing the sum of all the
elements in the input field.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a scalar field to a 0D scalar containing the sum of all the
elements in the input field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>0D scalar field holding the sum of values in input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.platform.types.FieldParameters#fieldShape" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldShape:cogx.cogmath.geometry.Shape"></a>
      <a id="fieldShape:cogmath.geometry.Shape"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">fieldShape</span><span class="result">: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldShape:cogx.cogmath.geometry.Shape" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shape of the field.</p><div class="fullcomment"><div class="comment cmt"><p>Shape of the field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>FieldParameters</dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToColorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToColorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ColorField"></a>
      <a id="fieldToColorField(Field):ColorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToColorField</span><span class="params">(<span name="f">f: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="ColorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ColorField">ColorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldToColorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ColorField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a ColorField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a ColorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ColorField but stored in a Field variable. This method also
supports converting a ScalarField or VectorField to a ColorField.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the ColorField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToComplexField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToComplexField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexField"></a>
      <a id="fieldToComplexField(Field):ComplexField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToComplexField</span><span class="params">(<span name="f">f: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="ComplexField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexField">ComplexField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldToComplexField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a ComplexField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a ComplexField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ComplexField but stored in a Field variable. This method also
supports converting a ScalarField to a ComplexField.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the ComplexField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToComplexVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToComplexVectorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexVectorField"></a>
      <a id="fieldToComplexVectorField(Field):ComplexVectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToComplexVectorField</span><span class="params">(<span name="f">f: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="ComplexVectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexVectorField">ComplexVectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldToComplexVectorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ComplexVectorField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a ComplexField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a ComplexField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ComplexField but stored in a Field variable. This method also
supports converting a ScalarField to a ComplexField.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the ComplexVectorField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToMatrixField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToMatrixField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.MatrixField"></a>
      <a id="fieldToMatrixField(Field):MatrixField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToMatrixField</span><span class="params">(<span name="f">f: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">MatrixField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldToMatrixField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.MatrixField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a MatrixField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a MatrixField. Since Field is abstract,
the only possible conversion is if the field is already a MatrixField but
is stored in a Field variable. This merely does the necessary type
coercion.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the MatrixField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToScalarField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToScalarField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ScalarField"></a>
      <a id="fieldToScalarField(Field):ScalarField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToScalarField</span><span class="params">(<span name="f">f: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">ScalarField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldToScalarField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.ScalarField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a ScalarField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a ScalarField. Since Field is abstract,
the only possible conversion is if the field is already a ScalarField but
is stored in a Field variable. This merely does the necessary type
coercion.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the ScalarField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#fieldToVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldToVectorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="fieldToVectorField(Field):VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldToVectorField</span><span class="params">(<span name="f">f: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldToVectorField(f:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Field to a VectorField.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Field to a VectorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a VectorField but stored in a Field variable. This method also
supports converting a ColorField to a VectorField.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A field which needs coercion to the VectorField type.</p></dd><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#fieldType" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldType:cogx.platform.types.FieldType"></a>
      <a id="fieldType:platform.types.FieldType"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">fieldType</span><span class="result">: <a href="../../../platform/types/FieldType.html" class="extype" name="cogx.platform.types.FieldType">platform.types.FieldType</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@fieldType:cogx.platform.types.FieldType" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The field type of the result.</p><div class="fullcomment"><div class="comment cmt"><p>The field type of the result.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → FieldParameters → RecurrenceTrait</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@finalize():Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#flip" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flip:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="flip:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flip</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@flip:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Flip a field along every dimension.</p><div class="fullcomment"><div class="comment cmt"><p>Flip a field along every dimension.</p><p> Example. This 2D scalar field:</p><pre><span class="num">1</span>  <span class="num">2</span>  <span class="num">3</span>
<span class="num">4</span>  <span class="num">5</span>  <span class="num">6</span>
<span class="num">7</span>  <span class="num">8</span>  <span class="num">9</span></pre><p> looks like this when flipped:</p><pre><span class="num">9</span>  <span class="num">8</span>  <span class="num">7</span>
<span class="num">6</span>  <span class="num">5</span>  <span class="num">4</span>
<span class="num">3</span>  <span class="num">2</span>  <span class="num">1</span></pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A flipped version of the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#floatToCogFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="floatToCogFloat(f:Float):cogx.compiler.parser.syntaxtree.CogFloat"></a>
      <a id="floatToCogFloat(Float):CogFloat"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">floatToCogFloat</span><span class="params">(<span name="f">f: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="CogFloat.html" class="extype" name="cogx.compiler.parser.syntaxtree.CogFloat">CogFloat</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@floatToCogFloat(f:Float):cogx.compiler.parser.syntaxtree.CogFloat" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Float to a CogFloat which allows for fields
to be combined with floating point numbers in a simple way.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Float to a CogFloat which allows for fields
to be combined with floating point numbers in a simple way.
This makes it possible to express commutative operations with a common
syntax.</p><p>For example</p><pre>Field + <span class="std">Float</span></pre><p>and</p><pre><span class="std">Float</span> + Field</pre><p>are both legal and compilable with this implicit conversion.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>The Float to be converted to a CogFloat</p></dd><dt>returns</dt><dd class="cmt"><p>The CogFloat created from <code>f</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#floor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="floor:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="floor:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">floor</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@floor:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Map each numeric element of the input field to the largest integer
which is less than or equal to that element.</p><div class="fullcomment"><div class="comment cmt"><p>Map each numeric element of the input field to the largest integer
which is less than or equal to that element.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field where every number element has been &quot;floored&quot; to an integer.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#forwardGradient" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="forwardGradient:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="forwardGradient:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">forwardGradient</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@forwardGradient:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the forward gradient of a 2D scalar or vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the forward gradient of a 2D scalar or vector field.</p><p>This is the adjoint operator of backwardDivergence.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>For a scalar field input, a vector field representing the
        forward gradient of the input; for a vector input field, an
        order 4 tensor field representing the forward gradient of the
        input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@getClass():Class[_]" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.RecurrenceTrait#hasRecurrence" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hasRecurrence:Boolean"></a>
      <a id="hasRecurrence:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hasRecurrence</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@hasRecurrence:Boolean" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RecurrenceTrait</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@hashCode():Int" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#imaginaryPart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="imaginaryPart:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="imaginaryPart:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">imaginaryPart</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@imaginaryPart:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extract the imaginary part of a complex field as a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Extract the imaginary part of a complex field as a scalar field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, with each element
       equal to the imaginary part of the corresponding complex element in
       the input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#inputs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inputs:Seq[cogx.compiler.parser.syntaxtree.Field]"></a>
      <a id="inputs:Seq[Field]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inputs</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@inputs:Seq[cogx.compiler.parser.syntaxtree.Field]" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The input fields that drive the operation that produces this field</p><div class="fullcomment"><div class="comment cmt"><p>The input fields that drive the operation that produces this field</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.CompilerError#internalError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="internalError(message:String):Unit"></a>
      <a id="internalError(String):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">internalError</span><span class="params">(<span name="message">message: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@internalError(message:String):Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Declare an internal error described by <code>message</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Declare an internal error described by <code>message</code>.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>CompilerError</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#invertMatrices" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="invertMatrices:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="invertMatrices:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">invertMatrices</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@invertMatrices:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Invert all matrices in a matrix field using Gauss-Jordan elimination.</p><div class="fullcomment"><div class="comment cmt"><p>Invert all matrices in a matrix field using Gauss-Jordan elimination.</p><p>This is numerically stable only for small matrices, and let's not even
get in to singular matrices. Be careful.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A matrix field where each matrix is the (approximate) inverse of
        the corresponding matrix in the input matrix field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@isInstanceOf[T0]:Boolean" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#isInstantiated" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstantiated:Boolean"></a>
      <a id="isInstantiated:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstantiated</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@isInstantiated:Boolean" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Check if <code>this</code> has been instantiated with a virtual field register.</p><div class="fullcomment"><div class="comment cmt"><p>Check if <code>this</code> has been instantiated with a virtual field register.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.platform.types.FieldParameters#layers" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="layers:Int"></a>
      <a id="layers:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">layers</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@layers:Int" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">&quot;Layers&quot; in the field.</p><div class="fullcomment"><div class="comment cmt"><p>&quot;Layers&quot; in the field. See class description for meaning of layers.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>FieldParameters</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#localMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localMax(neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="localMax(cogmath.algebra.real.Matrix):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">localMax</span><span class="params">(<span name="neighborhood">neighborhood: <a href="../../../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@localMax(neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Find the local maximum of a neighborhood centered on each pixel in a 2D
scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Find the local maximum of a neighborhood centered on each pixel in a 2D
scalar field.</p><p>For each point in the input 2D scalar field, this searches a small
neighborhood of that point and extracts the largest scalar found.</p><p>The <code>neighborhood</code> is defined by a matrix which is centered on the point. A
non-zero value in the kernel means the corresponding point in the field
is part of the neighborhood, while a zero implies the point should be
ignored.</p><p>For example, the kernel</p><pre><span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">0</span> <span class="num">0</span> <span class="num">0</span></pre><p>specifies the 2 x 2 neighborhood for the maximum value search.
</p></div><dl class="paramcmts block"><dt class="param">neighborhood</dt><dd class="cmt"><p>An odd-sized matrix describing the neighborhood for
       doing the local max search. TO DO: This will become a field rather
       than a matrix. XXX</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, where each
       element is equal to the local max of the input field as defined
       by <code>neighborhood</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#localMaxPosition" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localMaxPosition(neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="localMaxPosition(cogmath.algebra.real.Matrix):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">localMaxPosition</span><span class="params">(<span name="neighborhood">neighborhood: <a href="../../../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@localMaxPosition(neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For a scalar field, find the relative position of the local maximum of a
neighborhood centered on the current pixel.</p><div class="fullcomment"><div class="comment cmt"><p>For a scalar field, find the relative position of the local maximum of a
neighborhood centered on the current pixel. This is returned as vector
field, with each vector's tail at the current pixel and the head pointing
at the pixel containing the neighborhood's local maximum.</p><p>The <code>neighborhood</code> is defined by a matrix which is centered on the point. A
non-zero value in the kernel means the corresponding point in the field
is part of the neighborhood, while a zero implies the point should be
ignored.</p><p>For example, the kernel</p><pre><span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">0</span> <span class="num">0</span> <span class="num">0</span></pre><p>specifies the 2 x 2 neighborhood for the maximum value search.
</p></div><dl class="paramcmts block"><dt class="param">neighborhood</dt><dd class="cmt"><p>An odd-sized matrix describing the neighborhood for
       doing the local max search. TO DO: This will become a field rather
       than a matrix. XXX</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field with the same field shape as the input scalar
       field, with each vector pointing to the maximum value in the
       neighborhood relative to the center of the neighborhood.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#localMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localMin(neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="localMin(cogmath.algebra.real.Matrix):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">localMin</span><span class="params">(<span name="neighborhood">neighborhood: <a href="../../../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@localMin(neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Find the local minimum of a neighborhood centered on each pixel in a 2D
scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Find the local minimum of a neighborhood centered on each pixel in a 2D
scalar field.</p><p>For each point in the input 2D scalar field, this searches a small
neighborhood of that point and extracts the smallest scalar found.</p><p>The <code>neighborhood</code> is defined by a matrix which is centered on the point. A
non-zero value in the kernel means the corresponding point in the field
is part of the neighborhood, while a zero implies the point should be
ignored.</p><p>For example, the kernel</p><pre><span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">0</span> <span class="num">0</span> <span class="num">0</span></pre><p>specifies the 2 x 2 neighborhood for the minimum value search.
</p></div><dl class="paramcmts block"><dt class="param">neighborhood</dt><dd class="cmt"><p>An odd-sized matrix describing the neighborhood for
       doing the local max search. TO DO: This will become a field rather
       than a matrix. XXX</p></dd><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, where each
       element is equal to the local min of the input field as defined
       by <code>neighborhood</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#localMinPosition" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localMinPosition(neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="localMinPosition(cogmath.algebra.real.Matrix):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">localMinPosition</span><span class="params">(<span name="neighborhood">neighborhood: <a href="../../../cogmath/algebra/real/Matrix.html" class="extype" name="cogx.cogmath.algebra.real.Matrix">cogmath.algebra.real.Matrix</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@localMinPosition(neighborhood:cogx.cogmath.algebra.real.Matrix):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For a scalar field, find the relative position of the local minimum of a
neighborhood centered on the current pixel.</p><div class="fullcomment"><div class="comment cmt"><p>For a scalar field, find the relative position of the local minimum of a
neighborhood centered on the current pixel. This is returned as vector
field, with each vector's tail at the current pixel and the head pointing
at the pixel containing the neighborhood's local manimum.</p><p>The <code>neighborhood</code> is defined by a matrix which is centered on the point. A
non-zero value in the kernel means the corresponding point in the field
is part of the neighborhood, while a zero implies the point should be
ignored.</p><p>For example, the kernel</p><pre><span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">1</span> <span class="num">1</span> <span class="num">0</span>
<span class="num">0</span> <span class="num">0</span> <span class="num">0</span></pre><p>specifies the 2 x 2 neighborhood for the minimum value search.
</p></div><dl class="paramcmts block"><dt class="param">neighborhood</dt><dd class="cmt"><p>An odd-sized matrix describing the neighborhood for
       doing the local min search. TO DO: This will become a field rather
       than a matrix. XXX</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field with the same field shape as the input scalar
       field, with each vector pointing to the minimum value in the
       neighborhood relative to the center of the neighborhood.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#log" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="log:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="log:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">log</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@log:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the natural logarithm to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the natural logarithm to every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       log(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#magnitude" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="magnitude:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="magnitude:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">magnitude</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@magnitude:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the magnitude of each element in a complex field</p><div class="fullcomment"><div class="comment cmt"><p>Take the magnitude of each element in a complex field</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#matrixRow" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="matrixRow(index:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="matrixRow(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">matrixRow</span><span class="params">(<span name="index">index: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@matrixRow(index:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convert a matrix field to a vector field by stripping out one row
from each matrix in the field and making it a vector.</p><div class="fullcomment"><div class="comment cmt"><p>Convert a matrix field to a vector field by stripping out one row
from each matrix in the field and making it a vector.
</p></div><dl class="paramcmts block"><dt class="param">index</dt><dd class="cmt"><p>The index of the desired row to strip out of each matrix
       and use as a vector.</p></dd><dt>returns</dt><dd class="cmt"><p>A vector field made up of the stripped out vectors from the
       input matrix field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#max" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="max(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="max(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">max</span><span class="params">(<span name="f2">f2: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@max(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Select the maximum value of corresponding elements in two scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Select the maximum value of corresponding elements in two scalar fields.
</p></div><dl class="paramcmts block"><dt class="param">f2</dt><dd class="cmt"><p>Second scalar field to compare with <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Scalar field where each element is the largest corresponding
       elements in <code>this</code> or <code>f2</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#max" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="max(value:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="max(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">max</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@max(value:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>max(x, that)</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>max(x, that)</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">value</dt><dd class="cmt"><p>Operand for max operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>max(x, that)</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#maxPosition" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="maxPosition:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="maxPosition:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">maxPosition</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@maxPosition:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Find the location/position of the maximum element in a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Find the location/position of the maximum element in a scalar field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A 0D vector field containing a vector holding the indices of the
       maximum element.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#medianFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="medianFilter:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="medianFilter:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">medianFilter</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@medianFilter:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Filter a 2D input scalar field with a 3 x 3 median filter.</p><div class="fullcomment"><div class="comment cmt"><p>Filter a 2D input scalar field with a 3 x 3 median filter.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A 2D scalar field with the same field shape as the input, with
       each element median filtered.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#min" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="min(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="min(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">min</span><span class="params">(<span name="f2">f2: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@min(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Select the minimum value of corresponding elements in two scalar fields.</p><div class="fullcomment"><div class="comment cmt"><p>Select the minimum value of corresponding elements in two scalar fields.
</p></div><dl class="paramcmts block"><dt class="param">f2</dt><dd class="cmt"><p>Second scalar field to compare with <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Scalar field where each element is the smallest corresponding
       elements in <code>this</code> or <code>f2</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#min" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="min(value:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="min(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">min</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@min(value:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">For every element, <code>x</code>, in <code>this</code>, compute <code>min(x, that)</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.</p><div class="fullcomment"><div class="comment cmt"><p>For every element, <code>x</code>, in <code>this</code>, compute <code>min(x, that)</code>
where 1.0f represents a &quot;true&quot; result and 0.0f represents a &quot;false&quot; result.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt class="param">value</dt><dd class="cmt"><p>Operand for min operator.</p></dd><dt>returns</dt><dd class="cmt"><p>A field equal to <code>this</code> with each element, <code>x</code>, mapped to
        <code>min(x, that)</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.FieldName#name" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="name:String"></a>
      <a id="name:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">name</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@name:String" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Get the &quot;full&quot; name of a field, as a Scala-like path name.</p><div class="fullcomment"><div class="comment cmt"><p>Get the &quot;full&quot; name of a field, as a Scala-like path name.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="FieldName.html" class="extype" name="cogx.compiler.parser.syntaxtree.FieldName">FieldName</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@ne(x$1:AnyRef):Boolean" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#nonMaximumSuppression" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nonMaximumSuppression:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="nonMaximumSuppression:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nonMaximumSuppression</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@nonMaximumSuppression:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Forces locally non-maximum pixels to zero for both scalar fields and
vector fields.</p><div class="fullcomment"><div class="comment cmt"><p>Forces locally non-maximum pixels to zero for both scalar fields and
vector fields.</p><p>Locality is defined to be the 8 nearest neighbors to a given pixel. If a
pixel is greater than or equal to any of those neighbors, its value is
left intact on the output, otherwise it's set to zero. Note that border
pixels have only 5 nearest neighbors and corner pixels have only 3 nearest
neighbors, so those are the only ones checked.</p><p>Vector fields are treated as though they were an array of scalar fields,
so non-maximum suppression is executed independently on each.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A copy of the input field with locally non-maximum values set to
       zero.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#normalizeL1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="normalizeL1:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="normalizeL1:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">normalizeL1</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@normalizeL1:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Normalize a scalar field using the L1 norm.</p><div class="fullcomment"><div class="comment cmt"><p>Normalize a scalar field using the L1 norm.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A normalized copy of the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#normalizeL2" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="normalizeL2:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="normalizeL2:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">normalizeL2</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@normalizeL2:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Normalize a scalar field using the L2 norm.</p><div class="fullcomment"><div class="comment cmt"><p>Normalize a scalar field using the L2 norm.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A normalized copy of the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@notify():Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@notifyAll():Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#opcode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opcode:cogx.platform.types.Opcode"></a>
      <a id="opcode:Opcode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">opcode</span><span class="result">: <span class="extype" name="cogx.platform.types.Opcode">Opcode</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@opcode:cogx.platform.types.Opcode" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The opcode of the operation that produces this field</p><div class="fullcomment"><div class="comment cmt"><p>The opcode of the operation that produces this field</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → RecurrenceTrait</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#operation" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="operation:cogx.compiler.parser.syntaxtree.Operation"></a>
      <a id="operation:Operation"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">operation</span><span class="result">: <span class="extype" name="cogx.compiler.parser.syntaxtree.Operation">Operation</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@operation:cogx.compiler.parser.syntaxtree.Operation" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">The operation that creates this field.</p><div class="fullcomment"><div class="comment cmt"><p>The operation that creates this field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#orientedNonMaximumSuppression" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="orientedNonMaximumSuppression(orientation:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="orientedNonMaximumSuppression(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">orientedNonMaximumSuppression</span><span class="params">(<span name="orientation">orientation: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@orientedNonMaximumSuppression(orientation:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Forces locally non-maximum pixels to zero for calar fields,
but only when comparing the pixels on either side of
a given pixel, using <code>orientation</code> to define where to look for the
two pixels for comparison.</p><div class="fullcomment"><div class="comment cmt"><p>Forces locally non-maximum pixels to zero for calar fields,
but only when comparing the pixels on either side of
a given pixel, using <code>orientation</code> to define where to look for the
two pixels for comparison.
</p></div><dl class="paramcmts block"><dt class="param">orientation</dt><dd class="cmt"><p>A scalar field holding the local orientation of the
       input field at every point. Orientation ranges from -Pi/2 to Pi/2,
       where the corresponding orientation rotates clockwise from
      horizontal (-Pi/2) to vertical (0) to horizontal (Pi/2).</p></dd><dt>returns</dt><dd class="cmt"><p>A copy of the input field with locally non-maximum values set to
       zero.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#phase" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="phase:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="phase:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">phase</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@phase:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Take the phase of each element in a complex field.</p><div class="fullcomment"><div class="comment cmt"><p>Take the phase of each element in a complex field.</p><p>This is also commonly called <code>arg</code>. This is a number in the range
(-Pi, Pi]
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#pow" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pow(that:Float):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="pow(Float):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pow</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@pow(that:Float):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Raise each number in a field to the power <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Raise each number in a field to the power <code>that</code>.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Input field with every number raised to the power <code>that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#pow" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pow(that:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="pow(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pow</span><span class="params">(<span name="that">that: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@pow(that:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Raise each number in a field to the power <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Raise each number in a field to the power <code>that</code>.
The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Input field with every number raised to the power <code>that</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#printKernelCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="printKernelCode():Unit"></a>
      <a id="printKernelCode():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">printKernelCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@printKernelCode():Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Print out, if possible, GPU code that generates this field.</p><div class="fullcomment"><div class="comment cmt"><p>Print out, if possible, GPU code that generates this field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#probe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="probe(userName:String):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="probe(String):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">probe</span><span class="params">(<span name="userName">userName: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">null</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@probe(userName:String):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">User mechanism for marking a field as &quot;probed,&quot; optionally supplying a
name for the field.</p><div class="fullcomment"><div class="comment cmt"><p>User mechanism for marking a field as &quot;probed,&quot; optionally supplying a
name for the field.</p><p>If a field is visible to reflection, it will be automatically named.
In that case supplying a <code>userName</code> is unnecessary and not recommended.
</p></div><dl class="paramcmts block"><dt class="param">userName</dt><dd class="cmt"><p>User's name for the field. If not supplied, the field is
       probed but uses system-inferred naming for the field.</p></dd><dt>returns</dt><dd class="cmt"><p>The field being probed.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#projectFrame" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="projectFrame(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="projectFrame(Field,platform.types.BorderPolicy,platform.types.ConvolutionSamplingPolicy,Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">projectFrame</span><span class="params">(<span name="filter">filter: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="borderPolicy">borderPolicy: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span></span>, <span name="samplingPolicy">samplingPolicy: <span class="extype" name="cogx.platform.types.ConvolutionSamplingPolicy">platform.types.ConvolutionSamplingPolicy</span> = <span class="symbol"><span class="name"><a href="../../../package.html">NoSamplingConvolution</a></span></span></span>, <span name="batchSize">batchSize: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@projectFrame(filter:cogx.compiler.parser.syntaxtree.Field,borderPolicy:cogx.platform.types.BorderPolicy,samplingPolicy:cogx.platform.types.ConvolutionSamplingPolicy,batchSize:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Cross-correlate a vector field with a vector-field filter frame.</p><div class="fullcomment"><div class="comment cmt"><p>Cross-correlate a vector field with a vector-field filter frame.
</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>The filter to use for cross-correlation; must be square and
       with odd size in each dimension.</p></dd><dt class="param">borderPolicy</dt><dd class="cmt"><p>Policy to use for handling cross-correlation along
       borders, implicitly helps to determine size of output field.</p></dd><dt class="param">samplingPolicy</dt><dd class="cmt"><p>Upsampling, downsampling optionally embedded in the
       crossCorrelation, also helps to determine the size of output field.</p></dd><dt class="param">batchSize</dt><dd class="cmt"><p>The number of logical (possibly multi-plane) images present in the input field.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field cross-correlated with <code>filter</code> using the supplied
       border and sampling policies.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#random" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="random(bits:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="random(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">random</span><span class="params">(<span name="bits">bits: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@random(bits:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute a random field based on this input field using cellular
automaton based RNG.</p><div class="fullcomment"><div class="comment cmt"><p>Compute a random field based on this input field using cellular
automaton based RNG. The output ranges from [0 to 1] (inclusive) and is
uniformly distributed.
</p></div><dl class="paramcmts block"><dt class="param">bits</dt><dd class="cmt"><p>The number of bits of precision to use</p></dd><dt>returns</dt><dd class="cmt"><p>A Vector field where each point in the field is random</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#realPart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="realPart:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="realPart:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">realPart</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@realPart:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extract the real part of a complex field as a scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Extract the real part of a complex field as a scalar field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, with each element
       equal to the real part of the corresponding complex element in the
       input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#reciprocal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reciprocal:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reciprocal:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reciprocal</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@reciprocal:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Perform 1/x operation on every numeric element of a field.</p><div class="fullcomment"><div class="comment cmt"><p>Perform 1/x operation on every numeric element of a field.</p><p>Somewhat dangerous to use if any element in the field could be zero, since
the resulting element would be NaN which does not throw an exception.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Input field with each numeric element, x, mapped to 1/x.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.RecurrenceTrait#recurrence" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="recurrence:Option[cogx.compiler.parser.syntaxtree.Field]"></a>
      <a id="recurrence:Option[Field]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">recurrence</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@recurrence:Option[cogx.compiler.parser.syntaxtree.Field]" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Read the current recurrence input, if any.</p><div class="fullcomment"><div class="comment cmt"><p>Read the current recurrence input, if any.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>RecurrenceTrait</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.RecurrenceTrait#recurrence_=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="recurrence_=(that:cogx.compiler.parser.syntaxtree.Field):Unit"></a>
      <a id="recurrence_=(Field):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: recurrence_$eq" class="name">recurrence_=</span><span class="params">(<span name="that">that: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@recurrence_=(that:cogx.compiler.parser.syntaxtree.Field):Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Write the recurrent input, making sure it's legal.</p><div class="fullcomment"><div class="comment cmt"><p>Write the recurrent input, making sure it's legal.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>RecurrenceTrait</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#reduceMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduceMax:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reduceMax:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceMax</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@reduceMax:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a scalar field by mapping each vector to the
maximum of its components.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a scalar field by mapping each vector to the
maximum of its components.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A scalar field with each element equal to the maximum of
       the components of the corresponding vector in the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#reduceMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduceMin:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reduceMin:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceMin</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@reduceMin:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a scalar field by mapping each vector to the
minimum of its components.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a scalar field by mapping each vector to the
minimum of its components.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A scalar field with each element equal to the minimum of
       the components of the corresponding vector in the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#reduceSum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduceSum:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reduceSum:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduceSum</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@reduceSum:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reduce a vector field to a scalar field by mapping each vector to the
sum of its components.</p><div class="fullcomment"><div class="comment cmt"><p>Reduce a vector field to a scalar field by mapping each vector to the
sum of its components.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A scalar field with each element equal to the sum of components of
       the corresponding vector in the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#replicate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="replicate(shape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="replicate(cogmath.geometry.Shape):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">replicate</span><span class="params">(<span name="shape">shape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@replicate(shape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Replicate a scalar field as matrices in a matrix field (each matrix in
the matrix field is identical to the input scalar field).</p><div class="fullcomment"><div class="comment cmt"><p>Replicate a scalar field as matrices in a matrix field (each matrix in
the matrix field is identical to the input scalar field).
</p></div><dl class="paramcmts block"><dt class="param">shape</dt><dd class="cmt"><p>The shape of the resulting output field.</p></dd><dt>returns</dt><dd class="cmt"><p>A matrix field with the same field shape as <code>f2</code> and tensor
       shape the same as the input scalar field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#reshape" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reshape(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,checkLegacyReshape:Boolean):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reshape(cogmath.geometry.Shape,cogmath.geometry.Shape,Boolean):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reshape</span><span class="params">(<span name="fieldShape">fieldShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="tensorShape">tensorShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="checkLegacyReshape">checkLegacyReshape: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol"><span class="name"><a href="../../../package.html">Cog.checkLegacyReshape</a></span></span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@reshape(fieldShape:cogx.cogmath.geometry.Shape,tensorShape:cogx.cogmath.geometry.Shape,checkLegacyReshape:Boolean):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Change the shape of a scalar field without changing the number of
elements in it.</p><div class="fullcomment"><div class="comment cmt"><p>Change the shape of a scalar field without changing the number of
elements in it.</p><p>This depends on the row-major ordering we use for elements in a field.
Elements in any scalar field, regardless of dimension, have that linear
ordering. Reshaping preserves that ordering; it really does nothing
more than change the sizes of each dimension of the field.
</p></div><dl class="paramcmts block"><dt class="param">fieldShape</dt><dd class="cmt"><p>the output field shape to use</p></dd><dt class="param">tensorShape</dt><dd class="cmt"><p>the output tensor shape to use</p></dd><dt class="param">checkLegacyReshape</dt><dd class="cmt"><p>Warn of uses of reshape that had different behaviors prior to libcog 4.3</p></dd><dt>returns</dt><dd class="cmt"><p>The input field, reshaped, with the same elements in the same
       linear order.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#reshape" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reshape(size:Int*):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reshape(Int*):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reshape</span><span class="params">(<span name="size">size: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@reshape(size:Int*):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Change the shape of a scalar field without changing the number of
elements in it.</p><div class="fullcomment"><div class="comment cmt"><p>Change the shape of a scalar field without changing the number of
elements in it.</p><p>This depends on the row-major ordering we use for elements in a field.
Elements in any scalar field, regardless of dimension, have that linear
ordering. Reshaping preserves that ordering; it really does nothing
more than change the sizes of each dimension of the field.
</p></div><dl class="paramcmts block"><dt class="param">size</dt><dd class="cmt"><p>A sequence of new sizes for each dimensions. The product of
       this sequence must equal the number of elements in the input
       field.</p></dd><dt>returns</dt><dd class="cmt"><p>The input field, reshaped, with the same elements in the same
       linear order.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.RestoreHooks#restoreParameters" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="restoreParameters:String"></a>
      <a id="restoreParameters:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">restoreParameters</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@restoreParameters:String" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A hook that should be overridden by users to supply the info needed to reconstruct the sensor or actuator.</p><div class="fullcomment"><div class="comment cmt"><p>A hook that should be overridden by users to supply the info needed to reconstruct the sensor or actuator.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="RestoreHooks.html" class="extype" name="cogx.compiler.parser.syntaxtree.RestoreHooks">RestoreHooks</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.RestoreHooks#restoringClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="restoringClass:AnyRef"></a>
      <a id="restoringClass:AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">restoringClass</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@restoringClass:AnyRef" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A hook that should be overridden by users if necessary to point to a class with a restore method.</p><div class="fullcomment"><div class="comment cmt"><p>A hook that should be overridden by users if necessary to point to a class with a restore method.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="RestoreHooks.html" class="extype" name="cogx.compiler.parser.syntaxtree.RestoreHooks">RestoreHooks</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#reverseCrossDot" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reverseCrossDot(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="reverseCrossDot(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reverseCrossDot</span><span class="params">(<span name="f2">f2: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@reverseCrossDot(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Multiply a matrix field, <code>this</code>, by a scalar field, <code>f2</code>, to produce a
scalar field.</p><div class="fullcomment"><div class="comment cmt"><p>Multiply a matrix field, <code>this</code>, by a scalar field, <code>f2</code>, to produce a
scalar field.</p><p>The matrix field and scalar field operands must have identical field
shapes. Each scalar element of the scalar field is multiplied by the
corresponding element in the matrix field. These products are then
summed to produce the scalar field result (which has the same shape as
the matrices in the matrix field).
</p></div><dl class="paramcmts block"><dt class="param">f2</dt><dd class="cmt"><p>Scalar field operand which have the same field shape as
       <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Product of <code>this</code> and <code>f2</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.platform.types.FieldParameters#rows" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rows:Int"></a>
      <a id="rows:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">rows</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@rows:Int" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">&quot;Rows&quot; in the field.</p><div class="fullcomment"><div class="comment cmt"><p>&quot;Rows&quot; in the field. See class description for meaning of rows.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>FieldParameters</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#shift" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shift(rowShift:Int,colShift:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="shift(Int,Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shift</span><span class="params">(<span name="rowShift">rowShift: <span class="extype" name="scala.Int">Int</span></span>, <span name="colShift">colShift: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@shift(rowShift:Int,colShift:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shift a 2D scalar field in both dimensions, pulling in zeroes where
necessary.</p><div class="fullcomment"><div class="comment cmt"><p>Shift a 2D scalar field in both dimensions, pulling in zeroes where
necessary.
</p></div><dl class="paramcmts block"><dt class="param">rowShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt class="param">colShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt>returns</dt><dd class="cmt"><p>Shifted input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#shift" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shift(colShift:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="shift(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shift</span><span class="params">(<span name="colShift">colShift: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@shift(colShift:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shift a 1D scalar field left (negative <code>colShift</code>) or right (positive
<code>colShift</code>), pulling in zeroes where necessary.</p><div class="fullcomment"><div class="comment cmt"><p>Shift a 1D scalar field left (negative <code>colShift</code>) or right (positive
<code>colShift</code>), pulling in zeroes where necessary.
</p></div><dl class="paramcmts block"><dt class="param">colShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt>returns</dt><dd class="cmt"><p>Shifted input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#shiftCyclic" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shiftCyclic(rowShift:Int,colShift:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="shiftCyclic(Int,Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shiftCyclic</span><span class="params">(<span name="rowShift">rowShift: <span class="extype" name="scala.Int">Int</span></span>, <span name="colShift">colShift: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@shiftCyclic(rowShift:Int,colShift:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shift a 2D scalar field in both dimensions, pulling in values from the opposite
side where necessary.</p><div class="fullcomment"><div class="comment cmt"><p>Shift a 2D scalar field in both dimensions, pulling in values from the opposite
side where necessary. Negative shift amounts result in shifts up and to the
left, while positive shift amounts result in shifts down and to the right.
</p></div><dl class="paramcmts block"><dt class="param">rowShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt class="param">colShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt>returns</dt><dd class="cmt"><p>Shifted input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#shiftCyclic" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shiftCyclic(colShift:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="shiftCyclic(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">shiftCyclic</span><span class="params">(<span name="colShift">colShift: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@shiftCyclic(colShift:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shift a 1D scalar field left (negative <code>colShift</code>) or right (positive
<code>colShift</code>), pulling in values from the opposite side where necessary.</p><div class="fullcomment"><div class="comment cmt"><p>Shift a 1D scalar field left (negative <code>colShift</code>) or right (positive
<code>colShift</code>), pulling in values from the opposite side where necessary.
</p></div><dl class="paramcmts block"><dt class="param">colShift</dt><dd class="cmt"><p>Number of pixels to shift field.</p></dd><dt>returns</dt><dd class="cmt"><p>Shifted input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#signum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="signum:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="signum:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">signum</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@signum:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the signum operator to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the signum operator to every numeric element in <code>this</code>.</p><p>Signum(x) is defined to be:</p><p> 1 if x &gt; 0</p><p> 0 if x == 0</p><p>-1 if x &lt; 0
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       signum(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#sin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sin:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="sin:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sin</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@sin:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the sine operator to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the sine operator to every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       sin(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#sinh" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sinh:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="sinh:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sinh</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@sinh:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the hyperbolic sine operator to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the hyperbolic sine operator to every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       sinh(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.cogmath.hypercircuit.Hyperedge#sinks" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sinks:Seq[T]"></a>
      <a id="sinks:Seq[Operation]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sinks</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="cogx.compiler.parser.syntaxtree.Operation">Operation</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@sinks:Seq[T]" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Get the sinks of this hyperedge.</p><div class="fullcomment"><div class="comment cmt"><p>Get the sinks of this hyperedge.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>Hyperedge</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#solve" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="solve(b:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="solve(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">solve</span><span class="params">(<span name="b">b: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@solve(b:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Solve Ax = b for x, where A is matrix field, <code>this</code>, and b is the
vector field argument.</p><div class="fullcomment"><div class="comment cmt"><p>Solve Ax = b for x, where A is matrix field, <code>this</code>, and b is the
vector field argument.</p><p>This actually solves the equation for each matrix / vector pair in the
fields <code>this</code> and <code>b</code>, producing a vector field representing x. The
vectors in b must be length 2 and the matrices in <code>this</code> must be 2 x 2.
Solves the equations using the pseudo inverse
</p></div><dl class="paramcmts block"><dt class="param">b</dt><dd class="cmt"><p>Vector field argument.</p></dd><dt>returns</dt><dd class="cmt"><p>The solution, x, to the set of linear equations.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.cogmath.hypercircuit.Hyperedge#source" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="source:T"></a>
      <a id="source:Operation"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">source</span><span class="result">: <span class="extype" name="cogx.compiler.parser.syntaxtree.Operation">Operation</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@source:T" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Get the source of this hyperedge.</p><div class="fullcomment"><div class="comment cmt"><p>Get the source of this hyperedge.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>Hyperedge</dd></dl></div>
    </li><li name="cogx.cogmath.hypercircuit.Hyperedge#sourceOutputIndex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sourceOutputIndex:Option[Int]"></a>
      <a id="sourceOutputIndex:Option[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sourceOutputIndex</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@sourceOutputIndex:Option[Int]" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Get the output index of this hyperedge on the source.</p><div class="fullcomment"><div class="comment cmt"><p>Get the output index of this hyperedge on the source.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>Hyperedge</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#sq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sq:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="sq:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sq</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@sq:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the square operator to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the square operator to every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       (x * x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#sqrt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sqrt:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="sqrt:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sqrt</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@sqrt:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the square root operator to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the square root operator to every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       sqrt(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.cogmath.hypercircuit.Hyperedge#stealSinksFrom" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stealSinksFrom(from:cogx.cogmath.hypercircuit.Hyperedge[T],exceptSink:T):Unit"></a>
      <a id="stealSinksFrom(Hyperedge[Operation],Operation):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stealSinksFrom</span><span class="params">(<span name="from">from: <span class="extype" name="cogx.cogmath.hypercircuit.Hyperedge">Hyperedge</span>[<span class="extype" name="cogx.compiler.parser.syntaxtree.Operation">Operation</span>]</span>, <span name="exceptSink">exceptSink: <span class="extype" name="cogx.compiler.parser.syntaxtree.Operation">Operation</span> = <span class="symbol">null.asInstanceOf[T]</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@stealSinksFrom(from:cogx.cogmath.hypercircuit.Hyperedge[T],exceptSink:T):Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Steal sinks from another edge, <code>from</code>, and add them to <code>this.</code> One can
avoid stealing sinks that are a single <code>exceptSink</code> node.</p><div class="fullcomment"><div class="comment cmt"><p>Steal sinks from another edge, <code>from</code>, and add them to <code>this.</code> One can
avoid stealing sinks that are a single <code>exceptSink</code> node.  This is useful in
merging a source node into a sink node, where the source -&gt; sink connection
is probed or has additional sinks outside the merged kernel.  In that case,
the output of the merged kernel wants to steal the sinks of the source -&gt; sink
connection edge, but does not want to include the sink.</p><p>This makes the <code>from</code> useless since it is no longer used by any other node.
</p></div><dl class="paramcmts block"><dt class="param">from</dt><dd class="cmt"><p>The edge from which to steal outputs;</p></dd><dt class="param">exceptSink</dt><dd class="cmt"><p>The sink to not transfer from <code>from</code> to <code>this</code>;</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd>Hyperedge</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#subfield" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subfield(guide:cogx.compiler.parser.syntaxtree.Field,shape:cogx.cogmath.geometry.Shape,border:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="subfield(Field,cogmath.geometry.Shape,platform.types.BorderPolicy):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subfield</span><span class="params">(<span name="guide">guide: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="shape">shape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>, <span name="border">border: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span> = <span class="symbol"><span class="name"><a href="../../../package.html">BorderClamp</a></span></span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@subfield(guide:cogx.compiler.parser.syntaxtree.Field,shape:cogx.cogmath.geometry.Shape,border:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extracts a window from a 1D or 2D scalar, vector or matrix field, guided by
a 0D vector field called &quot;the guide.&quot; The guide specifies the upper-left-most
(or left-most for 1D fields) point of the window, and <code>shape</code>
specifies the size of the window.</p><div class="fullcomment"><div class="comment cmt"><p>Extracts a window from a 1D or 2D scalar, vector or matrix field, guided by
a 0D vector field called &quot;the guide.&quot; The guide specifies the upper-left-most
(or left-most for 1D fields) point of the window, and <code>shape</code>
specifies the size of the window.</p><p>A guiding vector with value (v1, v2) means a given point (row, col) extracts
the element at location (row + v1, col + v2) as its output. If that location
falls outside of the field, the BorderPolicy attached to the the opcode
determines how the missing value is computed. If either of the guide vector
components v1 and v2 is non-integral, bilinear interpolation is used to
to determine the approximate value.
</p></div><dl class="paramcmts block"><dt class="param">guide</dt><dd class="cmt"><p>The guide vector.</p></dd><dt class="param">shape</dt><dd class="cmt"><p>Shape of the window.</p></dd><dt class="param">border</dt><dd class="cmt"><p>Policy for handling border processing.</p></dd><dt>returns</dt><dd class="cmt"><p>Extracted window.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#subfields" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subfields(diameter:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="subfields(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subfields</span><span class="params">(<span name="diameter">diameter: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@subfields(diameter:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Extract all subfields from a 2D scalar field into a 2-D vector field.</p><div class="fullcomment"><div class="comment cmt"><p>Extract all subfields from a 2D scalar field into a 2-D vector field.
</p></div><dl class="paramcmts block"><dt class="param">diameter</dt><dd class="cmt"><p>Sizes (rows and columns) of each subfield. Must be odd.</p></dd><dt>returns</dt><dd class="cmt"><p>A 2-D vector field where the length of the vector equals the
       number of <code>diameter</code> x <code>diameter</code> subfields in the input.
       For example, a 4 x 4 input field has four subfields of size 3 x 3,
       so this operator would return a 2-D vector field of size 3 x 3
       (the size of the subfields) with vectors of length 4.
       Each layer of the vector field is one subfield of of the input.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#supersample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="supersample:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="supersample:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">supersample</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@supersample:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Supersample a scalar field by 2X in each dimension, replicating pixels
to fill in the gaps.</p><div class="fullcomment"><div class="comment cmt"><p>Supersample a scalar field by 2X in each dimension, replicating pixels
to fill in the gaps.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Input field expanded by 2X in each dimension with pixel
replication.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@synchronized[T0](x$1:=&gt;T0):T0" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#tan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tan:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="tan:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tan</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@tan:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the tangent operator to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the tangent operator to every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       tan(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#tanh" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tanh:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="tanh:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tanh</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@tanh:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Apply the hyperbolic tangent operator to every numeric element in <code>this</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Apply the hyperbolic tangent operator to every numeric element in <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Field equal to input field with each element, x, mapped to
       tanh(x).</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.platform.types.FieldParameters#tensorOrder" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tensorOrder:Int"></a>
      <a id="tensorOrder:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">tensorOrder</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@tensorOrder:Int" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Order of the tensors in the field.</p><div class="fullcomment"><div class="comment cmt"><p>Order of the tensors in the field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>FieldParameters</dd></dl></div>
    </li><li name="cogx.platform.types.FieldParameters#tensorShape" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="tensorShape:cogx.cogmath.geometry.Shape"></a>
      <a id="tensorShape:cogmath.geometry.Shape"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">tensorShape</span><span class="result">: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@tensorShape:cogx.cogmath.geometry.Shape" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Shape of the tensors in the field.</p><div class="fullcomment"><div class="comment cmt"><p>Shape of the tensors in the field.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>FieldParameters</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#toColorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toColorField:cogx.compiler.parser.syntaxtree.ColorField"></a>
      <a id="toColorField:ColorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toColorField</span><span class="result">: <a href="ColorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ColorField">ColorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@toColorField:cogx.compiler.parser.syntaxtree.ColorField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a ColorField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a ColorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ColorField but stored in a Field variable. This method also
supports converting a ScalarField or VectorField to a ColorField.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#toComplexField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toComplexField:cogx.compiler.parser.syntaxtree.ComplexField"></a>
      <a id="toComplexField:ComplexField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toComplexField</span><span class="result">: <a href="ComplexField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexField">ComplexField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@toComplexField:cogx.compiler.parser.syntaxtree.ComplexField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a ComplexField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a ComplexField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ComplexField but stored in a Field variable. This method also
supports converting a ScalarField to a ComplexField.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#toComplexVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toComplexVectorField:cogx.compiler.parser.syntaxtree.ComplexVectorField"></a>
      <a id="toComplexVectorField:ComplexVectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toComplexVectorField</span><span class="result">: <a href="ComplexVectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ComplexVectorField">ComplexVectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@toComplexVectorField:cogx.compiler.parser.syntaxtree.ComplexVectorField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a ComplexVectorField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a ComplexVectorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a ComplexVectorField but stored in a Field variable. This method also
supports converting a VectorField to a ComplexVectorField.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#toGenericComplexField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toGenericComplexField:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="toGenericComplexField:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toGenericComplexField</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@toGenericComplexField:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Another explicit conversion, this time working on both ScalarFields and
VectorFields.</p><div class="fullcomment"><div class="comment cmt"><p>Another explicit conversion, this time working on both ScalarFields and
VectorFields. The return type is Field though, the common base class of
both ComplexFields and ComplexScalarFields.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#toMatrixField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toMatrixField:cogx.compiler.parser.syntaxtree.MatrixField"></a>
      <a id="toMatrixField:MatrixField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMatrixField</span><span class="result">: <a href="MatrixField.html" class="extype" name="cogx.compiler.parser.syntaxtree.MatrixField">MatrixField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@toMatrixField:cogx.compiler.parser.syntaxtree.MatrixField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a MatrixField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a MatrixField. Since Field is abstract,
the only possible conversion is if the field is already a MatrixField but
is stored in a Field variable. This merely does the necessary type
coercion.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#toScalarField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toScalarField:cogx.compiler.parser.syntaxtree.ScalarField"></a>
      <a id="toScalarField:ScalarField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toScalarField</span><span class="result">: <a href="ScalarField.html" class="extype" name="cogx.compiler.parser.syntaxtree.ScalarField">ScalarField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@toScalarField:cogx.compiler.parser.syntaxtree.ScalarField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a ScalarField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a ScalarField. Since Field is abstract,
the only possible conversion is if the field is already a ScalarField but
is stored in a Field variable. This merely does the necessary type
coercion.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.RecurrenceTrait#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@toString():String" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convert node to a string for debugging.</p><div class="fullcomment"><div class="comment cmt"><p>Convert node to a string for debugging.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>RecurrenceTrait → AnyRef → Any</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#toVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toVectorField:cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="toVectorField:VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toVectorField</span><span class="result">: <a href="VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@toVectorField:cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Explicit conversion of a Field to a VectorField.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit conversion of a Field to a VectorField. Field is abstract, so
this method will perform the appropriate type coercion if the field is
already a VectorField but stored in a Field variable. This method also
supports converting a ColorField to a VectorField.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The converted field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#transform" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transform(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="transform(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transform</span><span class="params">(<span name="f2">f2: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@transform(f2:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">(1) Multiply a matrix field by a matrix field to produce a matrix field; or
(2) multiply a matrix field by a vector field to produce a vector field.</p><div class="fullcomment"><div class="comment cmt"><p>(1) Multiply a matrix field by a matrix field to produce a matrix field; or
(2) multiply a matrix field by a vector field to produce a vector field.</p><p>For case (1), corresponding matrices in <code>this</code> and <code>f2</code> are multiplied
using standard matrix multiplication to produce the corresponding matrix
in the resulting matrix field.</p><p>For case (2), corresponding matrix/vector pair in <code>this</code> and <code>f2</code> are
multiplied using standard matrix/vector multiplication to produce the
corresponding vector (a linear transformation of the input vector)
in the resulting vector field.
</p></div><dl class="paramcmts block"><dt class="param">f2</dt><dd class="cmt"><p>Matrix field or vector field; must have the same field shape
      as <code>this</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>Matrix field or vector representing the matrix multiplications of
      corresponding elements in the two input fields.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#transpose" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transpose:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="transpose:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transpose</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@transpose:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Transpose a 2D tensor field or color field.</p><div class="fullcomment"><div class="comment cmt"><p>Transpose a 2D tensor field or color field.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#transposeMatrices" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transposeMatrices:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="transposeMatrices:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transposeMatrices</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@transposeMatrices:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Transpose all the matrices in a matrix field to produce a new matrix
field.</p><div class="fullcomment"><div class="comment cmt"><p>Transpose all the matrices in a matrix field to produce a new matrix
field.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Copy of input matrix field with all matrices transposed.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#transposeVectors" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transposeVectors:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="transposeVectors:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transposeVectors</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@transposeVectors:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Transpose each vector in a vector field to a single row matrix, thus
creating a matrix field from a vector field
</p><div class="fullcomment"><div class="comment cmt"><p>Transpose each vector in a vector field to a single row matrix, thus
creating a matrix field from a vector field
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Copy of input matrix field with all vectors transposed to
       single row matrices.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#trim" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="trim(resultShape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="trim(cogmath.geometry.Shape):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">trim</span><span class="params">(<span name="resultShape">resultShape: <a href="../../../cogmath/geometry/Shape.html" class="extype" name="cogx.cogmath.geometry.Shape">cogmath.geometry.Shape</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@trim(resultShape:cogx.cogmath.geometry.Shape):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">&quot;Trim&quot; a field to a smaller size by clipping off indices (maintaining the
origin).</p><div class="fullcomment"><div class="comment cmt"><p>&quot;Trim&quot; a field to a smaller size by clipping off indices (maintaining the
origin).
</p></div><dl class="paramcmts block"><dt class="param">resultShape</dt><dd class="cmt"><p>Desired shape of the resulting field; must not be
       larger in any dimension than the corresponding dimension of the
       input field</p></dd><dt>returns</dt><dd class="cmt"><p>The trimmed field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#unary_-" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unary_-():cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="unary_-():Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: unary_$minus" class="name">unary_-</span><span class="params">()</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@unary_-():cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Multiply each number in a field by -1.</p><div class="fullcomment"><div class="comment cmt"><p>Multiply each number in a field by -1.</p><p>The resulting field has the same field shape and tensor shape as <code>this</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The negative of the input field.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a> → <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#upsample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="upsample(factor:Int,phase:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="upsample(Int,Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">upsample</span><span class="params">(<span name="factor">factor: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">2</span></span>, <span name="phase">phase: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@upsample(factor:Int,phase:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Upsample with zeroes inserted between field points, increasing
the size of the input in all dimensions.</p><div class="fullcomment"><div class="comment cmt"><p>Upsample with zeroes inserted between field points, increasing
the size of the input in all dimensions.</p><p>Example: for input field {1,2,3}</p><p>   input.upsample(2) yields {1,0,2,0,3,0}</p><p>   input.upsample(2,1) yields {0,1,0,2,0,3}
</p></div><dl class="paramcmts block"><dt class="param">factor</dt><dd class="cmt"><p>The sampling factor, defaults to 2.</p></dd><dt class="param">phase</dt><dd class="cmt"><p>The offset within the scaled up field to put the input
       data, defaults to an offset of 0.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#vectorElement" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorElement(index:Int):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="vectorElement(Int):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorElement</span><span class="params">(<span name="index">index: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@vectorElement(index:Int):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convert a vector field to a scalar field by extracting one element of each
vector.</p><div class="fullcomment"><div class="comment cmt"><p>Convert a vector field to a scalar field by extracting one element of each
vector.
</p></div><dl class="paramcmts block"><dt class="param">index</dt><dd class="cmt"><p>The element of each vector to be extracted.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field with tensor order reduced by one.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#vectorElements" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorElements(indices:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="vectorElements(Field):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorElements</span><span class="params">(<span name="indices">indices: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@vectorElements(indices:cogx.compiler.parser.syntaxtree.Field):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Convert a vector field to a smaller vector field by extracting a dynamically
indexed a range of elements
</p><div class="fullcomment"><div class="comment cmt"><p>Convert a vector field to a smaller vector field by extracting a dynamically
indexed a range of elements
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Input field with tensor order reduced by one.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.api.ImplicitConversions#vectorTo0DVectorField" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vectorTo0DVectorField(v:cogx.cogmath.algebra.real.Vector):cogx.compiler.parser.syntaxtree.VectorField"></a>
      <a id="vectorTo0DVectorField(cogmath.algebra.real.Vector):VectorField"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">vectorTo0DVectorField</span><span class="params">(<span name="v">v: <a href="../../../cogmath/algebra/real/Vector.html" class="extype" name="cogx.cogmath.algebra.real.Vector">cogmath.algebra.real.Vector</a></span>)</span><span class="result">: <a href="VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">VectorField</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@vectorTo0DVectorField(v:cogx.cogmath.algebra.real.Vector):cogx.compiler.parser.syntaxtree.VectorField" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Implicit conversion of a Vector to a 0D constant VectorField which allows
for fields to be combined with vectors in a simple way.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion of a Vector to a 0D constant VectorField which allows
for fields to be combined with vectors in a simple way.
This makes it possible to express commutative operations with a common
syntax.</p><p>For example</p><pre>Field + Vector</pre><p>and</p><pre>Vector + Field</pre><p>are both legal and compilable with this implicit conversion.
</p></div><dl class="paramcmts block"><dt class="param">v</dt><dd class="cmt"><p>The vector to be converted to a 0D vector field.</p></dd><dt>returns</dt><dd class="cmt"><p>A 0D vector field initialized to <code>v</code>.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@wait():Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@wait(x$1:Long,x$2:Int):Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@wait(x$1:Long):Unit" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#warp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="warp(guide:cogx.compiler.parser.syntaxtree.Field,border:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="warp(Field,platform.types.BorderPolicy):Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">warp</span><span class="params">(<span name="guide">guide: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>, <span name="border">border: <span class="extype" name="cogx.platform.types.BorderPolicy">platform.types.BorderPolicy</span> = <span class="symbol"><span class="name"><a href="../../../package.html">BorderClamp</a></span></span></span>)</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@warp(guide:cogx.compiler.parser.syntaxtree.Field,border:cogx.platform.types.BorderPolicy):cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Warps a 2D scalar, vector or matrix field, guided by a vector field
called &quot;the guide.&quot; The guide must either be zero-dimensional, in which
case the input field is translated uniformly, or must be a 2D vector
field with exactly the same shape as the input.</p><div class="fullcomment"><div class="comment cmt"><p>Warps a 2D scalar, vector or matrix field, guided by a vector field
called &quot;the guide.&quot; The guide must either be zero-dimensional, in which
case the input field is translated uniformly, or must be a 2D vector
field with exactly the same shape as the input.</p><p>The guiding vector with value (v1, v2) at a given point (row, col) extracts
the element at location (row - v1, col - v2) as its output. If that location
falls outside of the field, the BorderPolicy attached to the the opcode
determines how the missing value is computed. If either of the guide vector
components v1 and v2 is non-integral, bilinear interpolation is used to
to determine the approximate value.
</p></div><dl class="paramcmts block"><dt class="param">guide</dt><dd class="cmt"><p>The guiding vector field.</p></dd><dt class="param">border</dt><dd class="cmt"><p>Policy for handling borders.</p></dd><dt>returns</dt><dd class="cmt"><p>Input field, warped by the guide.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li><li name="cogx.cogmath.hypercircuit.Hyperedge#weight" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="weight:Double"></a>
      <a id="weight:Double"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">weight</span><span class="result">: <span class="extype" name="scala.Double">Double</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@weight:Double" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Every hyperedge has a weight which is application defined.</p><div class="fullcomment"><div class="comment cmt"><p>Every hyperedge has a weight which is application defined.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>Hyperedge</dd></dl></div>
    </li><li name="cogx.compiler.parser.syntaxtree.Field#winnerTakeAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="winnerTakeAll:cogx.compiler.parser.syntaxtree.Field"></a>
      <a id="winnerTakeAll:Field"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">winnerTakeAll</span><span class="result">: <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../index.html#cogx.compiler.parser.syntaxtree.UnpipelinedVectorSensor@winnerTakeAll:cogx.compiler.parser.syntaxtree.Field" title="Permalink" target="_top">
        <img src="../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Compute the &quot;winner&quot; of a scalar field by mapping its largest element
to 1.0f and the other elements to 0.0f</p><div class="fullcomment"><div class="comment cmt"><p>Compute the &quot;winner&quot; of a scalar field by mapping its largest element
to 1.0f and the other elements to 0.0f</p><p>This is not well-defined when multiple elements share the maximum value,
so beware.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A scalar field with the same shape as the input, with a single
       element containing 1.0f and the rest containing 0.0f.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="cogx.compiler.parser.syntaxtree.RestoreHooks">
              <h3>Inherited from <a href="RestoreHooks.html" class="extype" name="cogx.compiler.parser.syntaxtree.RestoreHooks">RestoreHooks</a></h3>
            </div><div class="parent" name="cogx.compiler.parser.syntaxtree.VectorField">
              <h3>Inherited from <a href="VectorField.html" class="extype" name="cogx.compiler.parser.syntaxtree.VectorField">VectorField</a></h3>
            </div><div class="parent" name="cogx.compiler.parser.syntaxtree.Field">
              <h3>Inherited from <a href="Field.html" class="extype" name="cogx.compiler.parser.syntaxtree.Field">Field</a></h3>
            </div><div class="parent" name="cogx.api.CogOperatorAPI">
              <h3>Inherited from <a href="../../../api/CogOperatorAPI.html" class="extype" name="cogx.api.CogOperatorAPI">CogOperatorAPI</a></h3>
            </div><div class="parent" name="cogx.platform.types.FieldParameters">
              <h3>Inherited from <span class="extype" name="cogx.platform.types.FieldParameters">FieldParameters</span></h3>
            </div><div class="parent" name="cogx.compiler.parser.syntaxtree.FieldName">
              <h3>Inherited from <a href="FieldName.html" class="extype" name="cogx.compiler.parser.syntaxtree.FieldName">FieldName</a></h3>
            </div><div class="parent" name="cogx.api.ImplicitConversions">
              <h3>Inherited from <a href="../../../api/ImplicitConversions.html" class="extype" name="cogx.api.ImplicitConversions">ImplicitConversions</a></h3>
            </div><div class="parent" name="cogx.compiler.parser.syntaxtree.RecurrenceTrait">
              <h3>Inherited from <span class="extype" name="cogx.compiler.parser.syntaxtree.RecurrenceTrait">RecurrenceTrait</span></h3>
            </div><div class="parent" name="cogx.compiler.parser.semantics.SemanticError">
              <h3>Inherited from <span class="extype" name="cogx.compiler.parser.semantics.SemanticError">SemanticError</span></h3>
            </div><div class="parent" name="cogx.compiler.CompilerError">
              <h3>Inherited from <span class="extype" name="cogx.compiler.CompilerError">CompilerError</span></h3>
            </div><div class="parent" name="cogx.cogmath.hypercircuit.Hyperedge">
              <h3>Inherited from <span class="extype" name="cogx.cogmath.hypercircuit.Hyperedge">Hyperedge</span>[<span class="extype" name="cogx.compiler.parser.syntaxtree.Operation">Operation</span>]</h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
